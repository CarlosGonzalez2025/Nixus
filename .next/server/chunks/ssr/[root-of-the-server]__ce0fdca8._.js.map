{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-lg border bg-card text-card-foreground shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n"],"names":[],"mappings":";;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,qBAAO,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG1B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,4DACA;QAED,GAAG,KAAK;;;;;;AAGb,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,sDACA;QAED,GAAG,KAAK;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGrC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QAAI,KAAK;QAAK,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,YAAY;QAAa,GAAG,KAAK;;;;;;AAEhE,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGb,WAAW,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/dialog.tsx"],"sourcesContent":["\n\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogClose,\n  DialogTrigger,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,SAAS,kKAAA,CAAA,OAAoB;AAEnC,MAAM,gBAAgB,kKAAA,CAAA,UAAuB;AAE7C,MAAM,eAAe,kKAAA,CAAA,SAAsB;AAE3C,MAAM,cAAc,kKAAA,CAAA,QAAqB;AAEzC,MAAM,8BAAgB,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGnC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,kKAAA,CAAA,UAAuB;QACtB,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,0JACA;QAED,GAAG,KAAK;;;;;;AAGb,cAAc,WAAW,GAAG,kKAAA,CAAA,UAAuB,CAAC,WAAW;AAE/D,MAAM,8BAAgB,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGnC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,8OAAC;;0BACC,8OAAC;;;;;0BACD,8OAAC,kKAAA,CAAA,UAAuB;gBACtB,KAAK;gBACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,+fACA;gBAED,GAAG,KAAK;;oBAER;kCACD,8OAAC,kKAAA,CAAA,QAAqB;wBAAC,WAAU;;0CAC/B,8OAAC,4LAAA,CAAA,IAAC;gCAAC,WAAU;;;;;;0CACb,8OAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;AAKlC,cAAc,WAAW,GAAG,kKAAA,CAAA,UAAuB,CAAC,WAAW;AAE/D,MAAM,eAAe,CAAC,EACpB,SAAS,EACT,GAAG,OACkC,iBACrC,8OAAC;QACC,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,sDACA;QAED,GAAG,KAAK;;;;;;AAGb,aAAa,WAAW,GAAG;AAE3B,MAAM,eAAe,CAAC,EACpB,SAAS,EACT,GAAG,OACkC,iBACrC,8OAAC;QACC,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,iEACA;QAED,GAAG,KAAK;;;;;;AAGb,aAAa,WAAW,GAAG;AAE3B,MAAM,4BAAc,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,kKAAA,CAAA,QAAqB;QACpB,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,qDACA;QAED,GAAG,KAAK;;;;;;AAGb,YAAY,WAAW,GAAG,kKAAA,CAAA,QAAqB,CAAC,WAAW;AAE3D,MAAM,kCAAoB,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGvC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,kKAAA,CAAA,cAA2B;QAC1B,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,kBAAkB,WAAW,GAAG,kKAAA,CAAA,cAA2B,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 220, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/checkbox.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\nimport { Check } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Checkbox = React.forwardRef<\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <CheckboxPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n      className\n    )}\n    {...props}\n  >\n    <CheckboxPrimitive.Indicator\n      className={cn(\"flex items-center justify-center text-current\")}\n    >\n      <Check className=\"h-4 w-4\" />\n    </CheckboxPrimitive.Indicator>\n  </CheckboxPrimitive.Root>\n))\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\n\nexport { Checkbox }\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,yBAAW,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG9B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,oKAAA,CAAA,OAAsB;QACrB,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,kTACA;QAED,GAAG,KAAK;kBAET,cAAA,8OAAC,oKAAA,CAAA,YAA2B;YAC1B,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE;sBAEd,cAAA,8OAAC,oMAAA,CAAA,QAAK;gBAAC,WAAU;;;;;;;;;;;;;;;;AAIvB,SAAS,WAAW,GAAG,oKAAA,CAAA,OAAsB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 265, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,gBAAgB,CAAA,GAAA,gKAAA,CAAA,MAAG,AAAD,EACtB;AAGF,MAAM,sBAAQ,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAI3B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,iKAAA,CAAA,OAAmB;QAClB,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iBAAiB;QAC9B,GAAG,KAAK;;;;;;AAGb,MAAM,WAAW,GAAG,iKAAA,CAAA,OAAmB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 297, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/signature-pad.tsx"],"sourcesContent":["\n\"use client\";\n\nimport React, { useRef, useState, useEffect } from 'react';\nimport { Button } from './button';\nimport { Eraser, Loader2, Save } from 'lucide-react';\nimport { DialogFooter } from './dialog';\nimport { Checkbox } from './checkbox';\nimport { Label } from './label';\n\ninterface SignaturePadProps {\n  onSave: (signature: string) => void;\n  isSaving?: boolean;\n}\n\nexport const SignaturePad: React.FC<SignaturePadProps> = ({ onSave, isSaving = false }) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [hasConsented, setHasConsented] = useState(false);\n\n  const getCanvasContext = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return null;\n    return canvas.getContext('2d');\n  };\n\n  const resizeCanvas = () => {\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    if (canvas && container) {\n      canvas.width = container.offsetWidth;\n      canvas.height = 200; // Keep a fixed height or make it responsive too\n      const ctx = getCanvasContext();\n      if(ctx) {\n        ctx.strokeStyle = '#000';\n        ctx.lineWidth = 2;\n      }\n    }\n  };\n\n  useEffect(() => {\n    resizeCanvas();\n    window.addEventListener('resize', resizeCanvas);\n    return () => window.removeEventListener('resize', resizeCanvas);\n  }, []);\n\n  const startDrawing = (event: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n    event.preventDefault();\n    const ctx = getCanvasContext();\n    if (!ctx) return;\n    \n    const pos = getMousePos(event);\n    ctx.beginPath();\n    ctx.moveTo(pos.x, pos.y);\n    setIsDrawing(true);\n  };\n\n  const draw = (event: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n    event.preventDefault();\n    if (!isDrawing) return;\n    const ctx = getCanvasContext();\n    if (!ctx) return;\n\n    const pos = getMousePos(event);\n    ctx.lineTo(pos.x, pos.y);\n    ctx.stroke();\n  };\n\n  const stopDrawing = () => {\n    const ctx = getCanvasContext();\n    if (!ctx) return;\n    ctx.closePath();\n    setIsDrawing(false);\n  };\n  \n  const getMousePos = (event: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return { x: 0, y: 0 };\n    const rect = canvas.getBoundingClientRect();\n\n    let clientX, clientY;\n\n    if ('touches' in event.nativeEvent) {\n      if (event.nativeEvent.touches.length === 0) return { x: 0, y: 0};\n      clientX = event.nativeEvent.touches[0].clientX;\n      clientY = event.nativeEvent.touches[0].clientY;\n    } else {\n      clientX = (event.nativeEvent as MouseEvent).clientX;\n      clientY = (event.nativeEvent as MouseEvent).clientY;\n    }\n    \n    return {\n      x: clientX - rect.left,\n      y: clientY - rect.top,\n    };\n  }\n\n  const clearPad = () => {\n    const canvas = canvasRef.current;\n    const ctx = getCanvasContext();\n    if (canvas && ctx) {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n  };\n\n  const handleSave = () => {\n    const canvas = canvasRef.current;\n    if (canvas) {\n      const blank = document.createElement('canvas');\n      blank.width = canvas.width;\n      blank.height = canvas.height;\n      if(canvas.toDataURL() === blank.toDataURL()) {\n        alert(\"Por favor, provea una firma.\");\n        return;\n      }\n      \n      const dataUrl = canvas.toDataURL('image/png');\n      onSave(dataUrl);\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col items-center gap-4 w-full\" ref={containerRef}>\n      <canvas\n        ref={canvasRef}\n        className=\"border border-gray-300 rounded-md bg-white cursor-crosshair touch-none w-full\"\n        onMouseDown={startDrawing}\n        onMouseMove={draw}\n        onMouseUp={stopDrawing}\n        onMouseLeave={stopDrawing}\n        onTouchStart={startDrawing}\n        onTouchMove={draw}\n        onTouchEnd={stopDrawing}\n      />\n       <div className=\"flex items-start space-x-3 w-full\">\n        <Checkbox \n          id=\"consent\" \n          checked={hasConsented}\n          onCheckedChange={(checked) => setHasConsented(Boolean(checked))}\n          className=\"mt-1\"\n        />\n        <Label htmlFor=\"consent\" className=\"text-xs text-muted-foreground\">\n          Al firmar, doy mi consentimiento y estoy de acuerdo con la informaci√≥n relacionada dentro del permiso de trabajo y sus anexos. Adicionalmente, autorizo el tratamiento de mis datos personales conforme a lo establecido en la Ley 1581 de 2012 y su Decreto Reglamentario 1377 de 2013, para las finalidades descritas en la pol√≠tica de tratamiento de datos de la organizaci√≥n.\n        </Label>\n      </div>\n      <DialogFooter className=\"w-full\">\n         <Button variant=\"outline\" onClick={clearPad} disabled={isSaving}>\n          <Eraser className=\"mr-2 h-4 w-4\" />\n          Limpiar\n        </Button>\n        <Button onClick={handleSave} disabled={!hasConsented || isSaving}>\n          {isSaving ? <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" /> : <Save className=\"mr-2 h-4 w-4\" />}\n          {isSaving ? 'Guardando...' : 'Guardar Firma'}\n        </Button>\n      </DialogFooter>\n    </div>\n  );\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 526, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/permits/actions.ts"],"sourcesContent":["\n\n'use server';\n\nimport { adminDb, isAdminReady } from '@/lib/firebase-admin';\nimport { revalidatePath } from 'next/cache';\nimport type { Permit, ExternalWorker, PermitStatus, PermitClosure, Approval, UserRole, AnexoAltura, AnexoConfinado, AnexoEnergias, AnexoExcavaciones, AnexoIzaje, AnexoATS, PermitGeneralInfo, JustificacionATS, ValidacionDiaria, User, Notification } from '@/types';\nimport { FieldValue, UpdateData, Timestamp } from 'firebase-admin/firestore';\nimport { sendWhatsAppNotification } from '@/lib/notifications';\nimport { getEmailForUser, sendPermitUpdateEmail } from '@/lib/email';\nimport { config } from 'dotenv';\nconfig();\n\n// --- Funciones Auxiliares para Notificaciones ---\n\nconst getInvolvedUsers = async (permit: Permit): Promise<string[]> => {\n  const userIds = new Set<string>();\n\n  // 1. Creador del permiso\n  if (permit.createdBy) {\n    userIds.add(permit.createdBy);\n  }\n\n  // 2. Usuarios que han firmado\n  Object.values(permit.approvals || {}).forEach(approval => {\n    if (approval && approval.userId) {\n      userIds.add(approval.userId);\n    }\n  });\n\n  // 3. Roles administrativos o de supervisi√≥n que deber√≠an ser notificados\n  const adminsQuery = await adminDb.collection('users').where('role', 'in', ['admin', 'autorizante', 'lider_sst']).get();\n  adminsQuery.forEach(doc => userIds.add(doc.id));\n\n  return Array.from(userIds);\n};\n\nconst createNotification = async (\n  userId: string,\n  permit: Permit,\n  message: string,\n  type: Notification['type'],\n  triggeredBy: { uid: string, displayName: string | null }\n) => {\n  const notification: Omit<Notification, 'id'> = {\n    userId,\n    permitId: permit.id,\n    permitNumber: permit.number || '',\n    message,\n    type,\n    isRead: false,\n    createdAt: FieldValue.serverTimestamp() as Timestamp,\n    triggeredBy,\n  };\n  await adminDb.collection('notifications').add(notification as any);\n  \n  // Enviar correo electr√≥nico\n  const userEmail = await getEmailForUser(userId);\n  if (userEmail) {\n    await sendPermitUpdateEmail({\n      to: userEmail,\n      subject: `Actualizaci√≥n en Permiso SGTC: ${permit.number || permit.id}`,\n      html: `<p>${message}</p><p>Puedes ver los detalles del permiso haciendo clic <a href=\"${process.env.NEXT_PUBLIC_BASE_URL}/permits/${permit.id}\">aqu√≠</a>.</p>`\n    });\n  }\n};\n\n// --- Fin de Funciones de Notificaciones ---\n\nconst workTypesMap: {[key: string]: string} = {\n  'alturas': 'Trabajo en Alturas',\n  'confinado': 'Espacios Confinados',\n  'energia': 'Control de Energ√≠as',\n  'izaje': 'Izaje de Cargas',\n  'excavacion': 'Excavaciones',\n  'general': 'Trabajo General'\n};\n\nconst getWorkTypesString = (permit: Partial<Permit>): string => {\n  const selectedTypes: string[] = [];\n  if (permit.trabajoAlturas) selectedTypes.push('Trabajo en Alturas');\n  if (permit.espaciosConfinados) selectedTypes.push('Espacios Confinados');\n  if (permit.controlEnergia) selectedTypes.push('Control de Energ√≠as');\n  if (permit.izajeCargas) selectedTypes.push('Izaje de Cargas');\n  if (permit.excavaciones) selectedTypes.push('Excavaciones');\n  \n  if (selectedTypes.length === 0) {\n    if (permit.trabajoGeneral) return 'Trabajo General';\n    // Fallback for old data structure\n    if (permit.workType && Array.isArray(permit.workType)) {\n      return permit.workType.map(key => workTypesMap[key] || key).join(', ');\n    }\n    return 'Trabajo General';\n  }\n  return selectedTypes.join(', ');\n};\n\nconst getStatusText = (status: string) => {\n    const statusText: {[key: string]: string} = {\n      'borrador': 'Borrador',\n      'pendiente_revision': 'Pendiente de Revisi√≥n',\n      'aprobado': 'Aprobado',\n      'en_ejecucion': 'En Ejecuci√≥n',\n      'suspendido': 'Suspendido',\n      'cerrado': 'Cerrado',\n      'rechazado': 'Rechazado'\n    };\n    return statusText[status] || status;\n  };\n\nconst signatureRoles: { [key in 'solicitante' | 'autorizante' | 'mantenimiento' | 'lider_sst' | 'coordinador_alturas']: string } = {\n  coordinador_alturas: 'COORDINADOR DE TRABAJOS EN ALTURAS',\n  solicitante: 'QUIEN SOLICITA (L√çDER A CARGO DEL EQUIPO EJECUTANTE)',\n  autorizante: 'QUIEN AUTORIZA (JEFES Y DUE√ëOS DE AREA)',\n  mantenimiento: 'PERSONAL DE MANTENIMIENTO',\n  lider_sst: 'Firma SST',\n};\n\ntype PermitCreateData = Omit<Permit, 'id' | 'createdAt' | 'status' | 'createdBy' | 'number' | 'user' | 'approvals' | 'closure'> & {\n  userId: string;\n  userDisplayName: string | null;\n  userEmail: string | null;\n  userPhotoURL: string | null;\n};\n\nexport async function createPermit(data: PermitCreateData) {\n  if (!data.userId) {\n    return { success: false, error: 'User not authenticated' };\n  }\n   if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const { userId, userDisplayName, userEmail, userPhotoURL, ...permitData } = data;\n\n  const initialApprovals = {\n    solicitante: { status: 'pendiente' as const },\n    autorizante: { status: 'pendiente' as const },\n    mantenimiento: { status: 'pendiente' as const },\n    lider_sst: { status: 'pendiente' as const },\n    coordinador_alturas: { status: 'pendiente' as const },\n  };\n\n  const permitPayload: Omit<Permit, 'id'> = {\n    ...permitData,\n    status: 'pendiente_revision' as const,\n    createdBy: userId,\n    createdAt: FieldValue.serverTimestamp() as Timestamp,\n    user: {\n      displayName: userDisplayName,\n      email: userEmail,\n      photoURL: userPhotoURL,\n    },\n    approvals: initialApprovals,\n    trabajoAlturas: data.trabajoAlturas || false,\n    isSSTSignatureRequired: data.isSSTSignatureRequired || false,\n    closure: {},\n  };\n  \n  try {\n    const docRef = await adminDb.collection('permits').add(permitPayload as any);\n    const permitNumber = `PT-${Date.now()}-${docRef.id.substring(0, 6).toUpperCase()}`;\n    await docRef.update({ number: permitNumber });\n    \n    console.log('‚úÖ [Action] Permiso creado con √©xito en Firestore:', docRef.id);\n\n    const createdPermit = { ...permitPayload, id: docRef.id, number: permitNumber } as Permit;\n    const involvedUsers = await getInvolvedUsers(createdPermit);\n    const message = `Se cre√≥ un nuevo permiso de trabajo: #${permitNumber}`;\n    \n    for (const uid of involvedUsers) {\n      if (uid !== userId) {\n        await createNotification(uid, createdPermit, message, 'creation', { uid: userId, displayName: userDisplayName });\n      }\n    }\n\n    const workTypesText = getWorkTypesString(permitPayload);\n    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n    const permitUrl = `${baseUrl}/permits/${docRef.id}`;\n    \n    const messageBody = `*¬°Alerta de Seguridad SGPT!* üö®\nSe ha creado una nueva solicitud de permiso de trabajo.\n\nüìÑ *N√∫mero:* ${permitNumber}\nüë§ *Solicitante:* ${userDisplayName || 'N/A'}\nüõ†Ô∏è *Tipo de Trabajo:* ${workTypesText}\n\nPor favor, revise la solicitud para su aprobaci√≥n en el siguiente enlace:\n${permitUrl}`;\n    \n    await sendWhatsAppNotification(messageBody);\n    \n    revalidatePath('/permits');\n    revalidatePath('/dashboard');\n    \n    return { success: true, permitId: docRef.id, permitNumber };\n  } catch (error: any) {\n    console.error(\"‚ùå [Action] Error al crear permiso:\", error);\n    return { \n      success: false, \n      error: error.message || 'Could not create permit. Please try again.' \n    };\n  }\n}\n\nexport async function savePermitDraft(data: PermitCreateData & { draftId?: string }) {\n  if (!data.userId) {\n    return { success: false, error: 'User not authenticated' };\n  }\n  if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const { userId, userDisplayName, userEmail, userPhotoURL, draftId, ...permitData } = data;\n\n  const initialApprovals = {\n    solicitante: { status: 'pendiente' as const },\n    autorizante: { status: 'pendiente' as const },\n    mantenimiento: { status: 'pendiente' as const },\n    lider_sst: { status: 'pendiente' as const },\n    coordinador_alturas: { status: 'pendiente' as const },\n  };\n\n  const permitPayload: Omit<Permit, 'id' | 'createdAt'> = {\n    ...permitData,\n    status: 'borrador' as const,\n    createdBy: userId,\n    user: {\n      displayName: userDisplayName,\n      email: userEmail,\n      photoURL: userPhotoURL,\n    },\n    approvals: initialApprovals,\n    trabajoAlturas: data.trabajoAlturas || false,\n    isSSTSignatureRequired: data.isSSTSignatureRequired || false,\n  };\n\n  try {\n    if (draftId) {\n      // Actualizar un borrador existente\n      const docRef = adminDb.collection('permits').doc(draftId);\n      await docRef.update({ ...permitPayload, updatedAt: FieldValue.serverTimestamp() });\n      revalidatePath(`/permits/${draftId}`);\n      revalidatePath('/permits');\n      return { success: true, permitId: draftId, isUpdate: true };\n    } else {\n      // Crear un nuevo borrador\n      const payloadWithTimestamp = { ...permitPayload, createdAt: FieldValue.serverTimestamp() };\n      const docRef = await adminDb.collection('permits').add(payloadWithTimestamp as any);\n      revalidatePath('/permits');\n      return { success: true, permitId: docRef.id, isUpdate: false };\n    }\n  } catch (error: any) {\n    console.error(\"‚ùå [Action] Error al guardar borrador:\", error);\n    return { \n      success: false, \n      error: error.message || 'Could not save draft. Please try again.' \n    };\n  }\n}\n\nexport async function addSignatureAndNotify(\n  permitId: string, \n  role: 'solicitante' | 'autorizante' | 'mantenimiento' | 'lider_sst' | 'coordinador_alturas' | 'cierre_autoridad' | 'cierre_responsable' | 'cancelacion', \n  signatureType: 'firmaApertura' | 'firmaCierre',\n  signatureDataUrl: string,\n  user: { uid: string, displayName: string | null, role?: UserRole, empresa?: string },\n  comments?: string\n) {\n    if (!permitId || !role || !user || !user.uid || !user.role) {\n        return { success: false, error: 'Par√°metros inv√°lidos para guardar la firma.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n    }\n\n    try {\n        const docRef = adminDb.collection('permits').doc(permitId);\n        const permitDocBefore = await docRef.get();\n        if (!permitDocBefore.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n        const permitBeforeData = permitDocBefore.data() as Permit;\n\n        const updateData: UpdateData<Permit> = {};\n\n        // L√≥gica para manejar firmas de cierre y cancelaci√≥n\n        if (role.startsWith('cierre_') || role === 'cancelacion') {\n            const closureRole = role === 'cierre_autoridad' ? 'autoridad' : (role === 'cierre_responsable' ? 'responsable' : 'canceladoPor');\n            const closurePath = `closure.${closureRole}`;\n            \n            const existingClosureData = (permitBeforeData.closure as any)?.[closureRole] || {};\n\n            updateData[closurePath as keyof UpdateData<Permit>] = {\n                ...existingClosureData,\n                firma: signatureDataUrl,\n                nombre: user.displayName,\n                fecha: FieldValue.serverTimestamp() \n            };\n            \n            if (role === 'cancelacion') {\n                updateData['closure.razonCancelacion'] = comments || 'No especificado';\n                updateData['closure.cancelado'] = 'si';\n            }\n\n        } else {\n            // ‚úÖ VALIDACI√ìN DE PERMISOS ANTES DE FIRMAR\n            const canSign = await validateSignaturePermission(permitId, role, user);\n            if (!canSign.allowed) {\n                return { success: false, error: canSign.reason };\n            }\n\n            const approvalData: Partial<Approval> = {\n                status: 'aprobado',\n                firmaApertura: signatureDataUrl,\n                userName: user.displayName,\n                userId: user.uid,\n                signedAt: FieldValue.serverTimestamp() as any,\n                userRole: user.role,\n                userEmpresa: user.empresa || 'N/A',\n                comments: comments || '',\n            }\n            \n            updateData[`approvals.${role}`] = approvalData;\n            \n            // ‚úÖ L√ìGICA DE FIRMAS SEG√öN EL ROL\n            if (signatureType === 'firmaApertura') {\n                const validationPayload: ValidacionDiaria = { \n                    dia: 1, \n                    nombre: user.displayName || '', \n                    firma: signatureDataUrl, \n                    fecha: new Date().toISOString() \n                };\n                \n                // ‚úÖ SOLICITANTE FIRMA: Cambia de Borrador a Pendiente de Revisi√≥n\n                if (role === 'solicitante') {\n                    if (permitBeforeData.status === 'borrador') {\n                        const permitNumber = `PT-${Date.now()}-${permitId.substring(0, 6).toUpperCase()}`;\n                        updateData['number'] = permitNumber;\n                        updateData['status'] = 'pendiente_revision';\n                    }\n                    \n                    // Validaci√≥n diaria inicial del responsable\n                    ['anexoAltura', 'anexoConfinado', 'anexoIzaje', 'anexoExcavaciones'].forEach(anexo => {\n                        if ((permitBeforeData as any)?.[anexo]) {\n                            const currentValidations = (permitBeforeData as any)[anexo].validacion?.responsable || [];\n                            if (!currentValidations[0]?.firma) {\n                                currentValidations[0] = validationPayload;\n                                updateData[`${anexo}.validacion.responsable`] = currentValidations;\n                            }\n                        }\n                    });\n\n                // ‚úÖ AUTORIZANTE FIRMA: Agrega validaci√≥n diaria de autoridad\n                } else if (role === 'autorizante') {\n                    ['anexoAltura', 'anexoConfinado', 'anexoIzaje', 'anexoExcavaciones'].forEach(anexo => {\n                        if ((permitBeforeData as any)?.[anexo]) {\n                           const currentValidations = (permitBeforeData as any)[anexo].validacion?.autoridad || [];\n                            if (!currentValidations[0]?.firma) {\n                                currentValidations[0] = validationPayload;\n                                updateData[`${anexo}.validacion.autoridad`] = currentValidations;\n                            }\n                        }\n                    });\n                }\n            }\n\n            // ‚úÖ VERIFICACI√ìN AUTOM√ÅTICA: ¬øTodas las firmas requeridas est√°n completas?\n            const updatedPermitData = { \n                ...permitBeforeData, \n                approvals: { ...permitBeforeData.approvals, [role]: approvalData }\n            };\n            \n            if (await checkAllRequiredSignaturesComplete(updatedPermitData)) {\n                // üöÄ CAMBIO AUTOM√ÅTICO DE PENDIENTE_REVISION ‚Üí EN_EJECUCION\n                if (permitBeforeData.status === 'pendiente_revision') {\n                    updateData['status'] = 'en_ejecucion';\n                }\n            }\n        }\n        \n        await docRef.update(updateData);\n        \n        const permitDoc = await docRef.get();\n        const updatedPermitData = { id: permitDoc.id, ...permitDoc.data() } as Permit;\n        \n        const signatureRoleName = (signatureRoles as any)[role] || role.replace('_', ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n        \n        const message = `${user.displayName || 'Un usuario'} ha firmado el permiso #${updatedPermitData.number} como ${signatureRoleName}.`;\n        const involvedUsers = await getInvolvedUsers(updatedPermitData);\n        \n        for (const uid of involvedUsers) {\n          if (uid !== user.uid) {\n            await createNotification(uid, updatedPermitData, message, 'signature', user);\n          }\n        }\n        \n        // ‚úÖ NOTIFICACI√ìN ESPECIAL SI EL PERMISO PAS√ì AUTOM√ÅTICAMENTE A EN_EJECUCION\n        if (updateData['status'] === 'en_ejecucion') {\n            const executionMessage = `El permiso #${updatedPermitData.number} ha completado todas las aprobaciones requeridas y ahora est√° EN EJECUCI√ìN.`;\n            for (const uid of involvedUsers) {\n                 await createNotification(uid, updatedPermitData, executionMessage, 'approval', user);\n            }\n            \n            // Notificaci√≥n WhatsApp\n            const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n            const permitUrl = `${baseUrl}/permits/${permitId}`;\n            const whatsappMsg = `*¬°PERMISO EN EJECUCI√ìN!* ‚úÖ\n\nüìÑ *N√∫mero:* ${updatedPermitData.number}\nüìç *√Årea:* ${permitBeforeData.generalInfo?.areaEspecifica || 'N/A'}\nüõ†Ô∏è *Tipo:* ${getWorkTypesString(permitBeforeData)}\n\n‚úÖ Todas las firmas requeridas han sido completadas.\nEl permiso est√° ahora EN EJECUCI√ìN.\n\nVer detalles: ${permitUrl}`;\n            \n            await sendWhatsAppNotification(whatsappMsg);\n        }\n\n        revalidatePath(`/permits/${permitId}`);\n        return { success: true };\n\n    } catch (error: any) {\n        console.error(\"‚ùå Error al guardar firma y notificar:\", error);\n        return {\n            success: false,\n            error: error.message || 'No se pudo guardar la firma.'\n        };\n    }\n}\n\n// ‚úÖ FUNCI√ìN CORREGIDA: Verificar si todas las firmas requeridas est√°n completas\nasync function checkAllRequiredSignaturesComplete(\n  permitData: Permit\n): Promise<boolean> {\n    const { approvals } = permitData;\n    \n    // Firma del solicitante es SIEMPRE requerida\n    if (approvals?.solicitante?.status !== 'aprobado') {\n        return false;\n    }\n    \n    // Firma del autorizante es SIEMPRE requerida\n    if (approvals?.autorizante?.status !== 'aprobado') {\n        return false;\n    }\n    \n    // Si hay trabajos en alturas, requiere firma del coordinador\n    if (permitData.trabajoAlturas || permitData.selectedWorkTypes?.alturas) {\n        if (approvals?.coordinador_alturas?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    // Si hay control de energ√≠a, requiere firma de mantenimiento\n    if (permitData.controlEnergia) {\n        if (approvals?.mantenimiento?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    // Si SST es requerido, validar su firma\n    if (permitData.isSSTSignatureRequired) {\n        if (approvals?.lider_sst?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n// ‚úÖ FUNCI√ìN MEJORADA: Validaci√≥n de transiciones de estado\nfunction validateStateTransition(currentStatus: PermitStatus, targetStatus: PermitStatus, userRole: UserRole): { allowed: boolean, reason?: string } {\n    const allowedTransitions: Partial<Record<PermitStatus, Partial<Record<PermitStatus, UserRole[]>>>> = {\n        'borrador': {\n            'pendiente_revision': ['solicitante', 'lider_tarea', 'admin']\n        },\n        'pendiente_revision': {\n            'en_ejecucion': ['autorizante', 'admin'],\n            'rechazado': ['autorizante', 'lider_sst', 'admin']\n        },\n        'en_ejecucion': {\n            'suspendido': ['lider_sst', 'admin'],\n            'cerrado': ['lider_tarea', 'autorizante', 'admin']\n        },\n        'suspendido': {\n            'en_ejecucion': ['lider_sst', 'admin'],\n            'cerrado': ['lider_tarea', 'autorizante', 'admin']\n        },\n        // Mantener compatibilidad con permisos antiguos que tengan estado \"aprobado\"\n        'aprobado': {\n            'en_ejecucion': ['lider_tarea', 'admin'],\n            'rechazado': ['autorizante', 'lider_sst', 'admin']\n        }\n    };\n    \n    const allowedRoles = allowedTransitions[currentStatus]?.[targetStatus];\n    if (!allowedRoles) {\n        return { allowed: false, reason: `Transici√≥n de '${currentStatus}' a '${targetStatus}' no est√° permitida.` };\n    }\n\n    if (!allowedRoles.includes(userRole) && userRole !== 'admin') {\n        return { allowed: false, reason: `Tu rol (${userRole}) no tiene permisos para cambiar el estado a '${targetStatus}'.` };\n    }\n\n    return { allowed: true };\n}\n\nexport async function updatePermitStatus(\n  permitId: string,\n  status: PermitStatus,\n  currentUser: { uid: string, displayName: string | null, role?: UserRole },\n  reason?: string\n) {\n    if (!permitId || !currentUser.uid || !currentUser.role) {\n        return { success: false, error: 'Par√°metros inv√°lidos o usuario sin rol.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas.' };\n    }\n\n    try {\n        const docRef = adminDb.collection('permits').doc(permitId);\n        const permitSnap = await docRef.get();\n        if (!permitSnap.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n        const permitData = permitSnap.data() as Permit;\n        \n        // ‚úÖ Validar transici√≥n de estado\n        const transition = validateStateTransition(permitData.status, status, currentUser.role);\n        if (!transition.allowed) {\n            return { success: false, error: transition.reason };\n        }\n\n        const updateData: UpdateData<Permit> = { status };\n\n        // ‚úÖ Guardar raz√≥n de rechazo\n        if (status === 'rechazado' && reason) {\n            updateData.rejectionReason = reason;\n        }\n        \n        // ‚úÖ Marcar fecha de cierre\n        if (status === 'cerrado') {\n            updateData['closure.fechaCierre'] = FieldValue.serverTimestamp();\n            updateData['closure.terminado'] = 'si';\n        }\n\n        await docRef.update(updateData);\n        \n        const updatedPermitData = { ...permitData, ...updateData, id: permitId } as Permit;\n        const triggeredBy = currentUser;\n        \n        let notificationType: Notification['type'] = 'status_change';\n        let message = `${currentUser.displayName || 'Un usuario'} ha cambiado el estado del permiso #${permitData.number} a: ${getStatusText(status)}.`;\n\n        if (status === 'en_ejecucion') {\n            notificationType = 'approval';\n            message = `El permiso #${permitData.number} ha sido puesto EN EJECUCI√ìN manualmente.`;\n        } else if (status === 'rechazado') {\n            notificationType = 'rejection';\n            message = `${currentUser.displayName || 'Un usuario'} ha rechazado el permiso #${permitData.number}.`;\n            if (reason) message += ` Motivo: ${reason}`;\n        } else if (status === 'cerrado') {\n            notificationType = 'cancellation';\n            message = `${currentUser.displayName || 'Un usuario'} ha cerrado el permiso #${permitData.number}.`;\n        }\n        \n        const involvedUsers = await getInvolvedUsers(updatedPermitData);\n        for (const uid of involvedUsers) {\n             if (uid !== currentUser.uid) {\n                await createNotification(uid, updatedPermitData, message, notificationType, triggeredBy);\n            }\n        }\n\n        const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n        const permitUrl = `${baseUrl}/permits/${permitId}`;\n\n        let messageBody = `*Actualizaci√≥n de Estado - SGTC* üîÑ\nEl estado del permiso *${permitData.number || permitId}* ha cambiado.\n\n*Nuevo Estado:* ${getStatusText(status)}\n\nPuede ver los detalles aqu√≠:\n${permitUrl}`;\n\n        if (status === 'rechazado' && reason) {\n          messageBody += `\\n\\n*Motivo del rechazo:* ${reason}`;\n        }\n        \n        await sendWhatsAppNotification(messageBody);\n        \n        revalidatePath(`/permits/${permitId}`);\n        revalidatePath('/permits');\n        revalidatePath('/dashboard');\n\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"‚ùå Error updating permit status:\", error);\n        return {\n            success: false,\n            error: error.message || 'Could not update permit status.'\n        };\n    }\n}\n\n// ‚úÖ FUNCI√ìN MEJORADA: Validaci√≥n de permisos de firma con orden jer√°rquico\nasync function validateSignaturePermission(\n    permitId: string, \n    signatureRole: string, \n    currentUser: { uid: string, role?: UserRole }\n): Promise<{ allowed: boolean, reason?: string }> {\n    const docRef = adminDb.collection('permits').doc(permitId);\n    const permitDoc = await docRef.get();\n    if (!permitDoc.exists) {\n        return { allowed: false, reason: 'Permiso no encontrado.' };\n    }\n    const permit = permitDoc.data() as Permit;\n    \n    // ‚úÖ Verificar que el permiso est√© en un estado v√°lido para firmar\n    if (!['borrador', 'pendiente_revision'].includes(permit.status)) {\n        return { allowed: false, reason: `No se puede firmar un permiso en estado '${permit.status}'.` };\n    }\n    \n    switch (signatureRole) {\n        case 'coordinador_alturas':\n            // Debe haber trabajo en alturas\n            if (!permit.trabajoAlturas && !permit.selectedWorkTypes?.alturas) {\n                return { allowed: false, reason: 'Esta firma solo aplica para trabajos en alturas.' };\n            }\n            // Solo el creador o admin puede gestionar esta firma\n            if (permit.createdBy !== currentUser.uid && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Solo el creador del permiso puede gestionar esta firma.' };\n            }\n            break;\n            \n        case 'solicitante':\n            if (permit.createdBy !== currentUser.uid && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Solo el creador del permiso puede firmar como solicitante.' };\n            }\n            // ‚úÖ Si hay anexo de alturas, verificar firma del coordinador primero\n            if ((permit.trabajoAlturas || permit.selectedWorkTypes?.alturas) && \n                permit.approvals?.coordinador_alturas?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del Coordinador de Trabajos en Alturas.' };\n            }\n            break;\n            \n        case 'autorizante':\n            if (currentUser.role !== 'autorizante' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de autorizante requerido para esta firma.' };\n            }\n            if (permit.approvals?.solicitante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del solicitante.' };\n            }\n            break;\n            \n        case 'lider_sst':\n            if (currentUser.role !== 'lider_sst' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de L√≠der SST requerido para esta firma.' };\n            }\n            // ‚úÖ Solo requerido si isSSTSignatureRequired es true\n            if (!permit.isSSTSignatureRequired) {\n                return { allowed: false, reason: 'Firma de SST no es requerida para este permiso.' };\n            }\n            if (permit.approvals?.solicitante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del solicitante.' };\n            }\n            break;\n            \n        case 'mantenimiento':\n             if (currentUser.role !== 'mantenimiento' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de Mantenimiento requerido para esta firma.' };\n            }\n            if (!permit.controlEnergia) {\n                return { allowed: false, reason: 'Firma de Mantenimiento solo aplica cuando hay control de energ√≠as.' };\n            }\n            if (permit.approvals?.autorizante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del autorizante.' };\n            }\n            break;\n    }\n    \n    return { allowed: true };\n}\n\nexport async function addDailyValidationSignature(\n  permitId: string, \n  anexoName: string, \n  validationType: 'autoridad' | 'responsable', \n  index: number, \n  data: ValidacionDiaria, \n  user: User\n) {\n  if (!permitId || !anexoName || !validationType || index < 0 || !data || !user) {\n    return { success: false, error: 'Par√°metros inv√°lidos.' };\n  }\n\n  if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const docRef = adminDb.collection('permits').doc(permitId);\n  try {\n    const permitSnap = await docRef.get();\n    if (!permitSnap.exists) {\n      return { success: false, error: 'El permiso no existe.' };\n    }\n    const permitData = permitSnap.data() as Permit;\n\n    // ‚úÖ Verificar que el permiso est√© en ejecuci√≥n para validaciones diarias\n    if (!['en_ejecucion', 'suspendido'].includes(permitData.status)) {\n        return { success: false, error: 'Solo se pueden agregar validaciones diarias en permisos EN EJECUCI√ìN o SUSPENDIDOS.' };\n    }\n\n    const anexoData = (permitData as any)[anexoName];\n    if (!anexoData) {\n      return { success: false, error: `El anexo ${anexoName} no existe en el permiso.` };\n    }\n    \n    const anexoUpdate: any = { ...anexoData };\n    if (!anexoUpdate.validacion) {\n        anexoUpdate.validacion = { autoridad: [], responsable: [] };\n    }\n\n    const validationArray = (anexoUpdate.validacion[validationType] as ValidacionDiaria[]) || [];\n    \n    while (validationArray.length <= index) {\n        validationArray.push({ dia: validationArray.length + 1, nombre: '', fecha: '', firma: '' });\n    }\n\n    validationArray[index] = data;\n    \n    const updatePath = `${anexoName}.validacion.${validationType}`;\n    \n    await docRef.update({\n      [updatePath]: validationArray,\n    });\n\n    const fullPermitData = { id: docRef.id, ...permitData } as Permit;\n    const anexoDisplayName = anexoName.replace('anexo', 'Anexo ');\n    const validationRoleName = validationType === 'autoridad' ? 'Autoridad del √Årea' : 'Responsable del Trabajo';\n    const day = index + 1;\n\n    const message = `${user.displayName || 'Un usuario'} ha realizado la validaci√≥n diaria (${validationRoleName}) para el D√çA ${day} del ${anexoDisplayName} en el permiso #${fullPermitData.number}.`;\n    const involvedUsers = await getInvolvedUsers(fullPermitData);\n    for (const uid of involvedUsers) {\n      if (uid !== user.uid) {\n        await createNotification(uid, fullPermitData, message, 'status_change', { uid: user.uid, displayName: user.displayName || null });\n      }\n    }\n\n    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n    const permitUrl = `${baseUrl}/permits/${permitId}`;\n    const whatsappMessage = `*Validaci√≥n Diaria - SGTC* ‚úçÔ∏è\nSe ha registrado una nueva firma de validaci√≥n diaria.\n\nüìÑ *Permiso:* ${fullPermitData.number || 'N/A'}\nüóìÔ∏è *D√≠a:* ${day}\nüë§ *Firmante:* ${user.displayName || 'N/A'}\n‚úÖ *Rol:* ${validationRoleName}\nüìã *Anexo:* ${anexoDisplayName}\n\nPuede ver los detalles aqu√≠:\n${permitUrl}`;\n    \n    await sendWhatsAppNotification(whatsappMessage);\n\n    revalidatePath(`/permits/${permitId}`);\n    return { success: true };\n\n  } catch (error: any) {\n    console.error(\"‚ùå Error al guardar la validaci√≥n diaria:\", error);\n    return { success: false, error: 'No se pudo guardar la firma de validaci√≥n.' };\n  }\n}\n\nexport async function addWorkerSignature(permitId: string, workerIndex: number, signatureType: 'firmaApertura' | 'firmaCierre', signatureDataUrl: string) {\n    if (!permitId || workerIndex < 0 || !signatureType || !signatureDataUrl) {\n        return { success: false, error: 'Faltan par√°metros.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n    }\n\n    const docRef = adminDb.collection('permits').doc(permitId);\n    try {\n        const permitSnap = await docRef.get();\n        if (!permitSnap.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n\n        const permitData = permitSnap.data() as Permit;\n        \n        // ‚úÖ CORRECCI√ìN: Validaci√≥n de estado corregida para firma de apertura\n        if (signatureType === 'firmaApertura' && !['pendiente_revision', 'aprobado', 'en_ejecucion'].includes(permitData.status)) {\n            return { success: false, error: 'Solo se puede firmar apertura cuando el permiso est√° pendiente, aprobado o en ejecuci√≥n.' };\n        }\n        if (signatureType === 'firmaCierre' && !['en_ejecucion', 'suspendido'].includes(permitData.status)) {\n            return { success: false, error: 'Solo se puede firmar cierre en permisos EN EJECUCI√ìN o SUSPENDIDOS.' };\n        }\n        \n        const workers = permitData.workers ? [...permitData.workers] : [];\n\n        if (workerIndex >= workers.length) {\n            return { success: false, error: '√çndice de trabajador inv√°lido.' };\n        }\n\n        const signatureField = signatureType === 'firmaApertura' ? 'firmaApertura' : 'firmaCierre';\n        const dateField = signatureType === 'firmaApertura' ? 'fechaFirmaApertura' : 'fechaFirmaCierre';\n\n        workers[workerIndex] = {\n            ...workers[workerIndex],\n            [signatureField]: signatureDataUrl,\n            [dateField]: new Date().toISOString(), \n        };\n\n        await docRef.update({ workers: workers });\n\n        revalidatePath(`/permits/${permitId}`);\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"Error al guardar la firma del trabajador:\", error);\n        return { success: false, error: 'No se pudo guardar la firma.' };\n    }\n}\n"],"names":[],"mappings":";;;;;;IAqQsB,wBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 539, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/permits/%5Bid%5D/components/SignatureCard.tsx"],"sourcesContent":["\n'use client';\nimport { useState } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\nimport { SignaturePad } from '@/components/ui/signature-pad';\nimport { addSignatureAndNotify } from '../../actions';\nimport { useUser } from '@/hooks/use-user';\nimport { useToast } from '@/hooks/use-toast';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport { CheckCircle, AlertCircle, Clock, FileSignature, Loader2 } from 'lucide-react';\nimport Image from 'next/image';\nimport { format } from 'date-fns';\nimport { es } from 'date-fns/locale';\nimport type { Approval, UserRole, User } from '@/types';\n\ninterface SignatureCardProps {\n  title: string;\n  approval: Partial<Approval>;\n  canSign: boolean;\n  permitId: string;\n  signatureRole: 'solicitante' | 'autorizante' | 'mantenimiento' | 'lider_sst' | 'coordinador_alturas';\n  disabled?: boolean;\n  tooltip?: string;\n}\n\nconst parseFirestoreDate = (dateValue: any): Date | null => {\n  if (!dateValue) return null;\n  // Handle Firestore Timestamp objects\n  if (typeof dateValue.toDate === 'function') {\n    return dateValue.toDate();\n  }\n  // Handle ISO strings\n  if (typeof dateValue === 'string') {\n    const date = new Date(dateValue);\n    if (!isNaN(date.getTime())) {\n        return date;\n    }\n  }\n  // Handle native Date objects\n  if (dateValue instanceof Date) {\n    return dateValue;\n  }\n  return null;\n};\n\n\nexport function SignatureCard({\n  title,\n  approval,\n  canSign,\n  permitId,\n  signatureRole,\n  disabled = false,\n  tooltip,\n}: SignatureCardProps) {\n  const { user } = useUser();\n  const { toast } = useToast();\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  const [isSaving, setIsSaving] = useState(false);\n\n  const handleSaveSignature = async (signature: string) => {\n    if (!user) {\n      toast({ variant: 'destructive', title: 'Error', description: 'Debe iniciar sesi√≥n para firmar.' });\n      return;\n    }\n    setIsSaving(true);\n    try {\n      const result = await addSignatureAndNotify(\n        permitId,\n        signatureRole,\n        'firmaApertura',\n        signature,\n        user as User,\n      );\n\n      if (result.success) {\n        toast({ title: 'Firma Guardada', description: 'Su firma ha sido registrada exitosamente.' });\n        setIsModalOpen(false);\n      } else {\n        throw new Error(result.error);\n      }\n    } catch (error: any) {\n      toast({ variant: 'destructive', title: 'Error al Firmar', description: error.message });\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const status = approval?.status || 'pendiente';\n  const signatureData = approval?.firmaApertura;\n  const signedAt = parseFirestoreDate(approval?.signedAt);\n  const userName = approval?.userName || 'N/A';\n  const userEmpresa = approval?.userEmpresa || 'N/A';\n  \n  const renderStatusIcon = () => {\n    switch (status) {\n      case 'aprobado':\n        return <CheckCircle className=\"h-6 w-6 text-green-500\" />;\n      case 'pendiente':\n        return <Clock className=\"h-6 w-6 text-yellow-500\" />;\n      default:\n        return <AlertCircle className=\"h-6 w-6 text-gray-500\" />;\n    }\n  };\n\n  return (\n    <Card className={status === 'aprobado' ? 'bg-green-50/50 border-green-200' : 'bg-background'}>\n      <CardHeader>\n        <div className=\"flex justify-between items-start\">\n          <div>\n            <CardTitle className=\"text-base font-bold\">{title}</CardTitle>\n            <CardDescription className=\"text-xs\">Estado: {status}</CardDescription>\n          </div>\n          {renderStatusIcon()}\n        </div>\n      </CardHeader>\n      <CardContent>\n        {status === 'aprobado' && signatureData ? (\n          <div className=\"flex flex-col sm:flex-row items-center gap-4\">\n            <div className=\"relative w-48 h-24 bg-white border rounded-md overflow-hidden\">\n                <Image src={signatureData} alt=\"Firma\" layout=\"fill\" objectFit=\"contain\" />\n            </div>\n            <div className=\"text-sm\">\n              <p><strong>Firmado por:</strong> {userName}</p>\n              <p><strong>Empresa:</strong> {userEmpresa}</p>\n              <p>\n                <strong>Fecha:</strong>{' '}\n                {signedAt ? format(signedAt, \"dd/MM/yyyy HH:mm\", { locale: es }) : 'N/A'}\n              </p>\n            </div>\n          </div>\n        ) : (\n           <TooltipProvider>\n            <Tooltip>\n                <TooltipTrigger asChild>\n                    <div className=\"w-full\">\n                        <Button \n                            onClick={() => setIsModalOpen(true)} \n                            disabled={!canSign || disabled}\n                            className=\"w-full\"\n                        >\n                            <FileSignature className=\"mr-2 h-4 w-4\" />\n                            Firmar como {signatureRole.replace('_', ' ')}\n                        </Button>\n                    </div>\n                </TooltipTrigger>\n                {(!canSign || disabled) && (\n                    <TooltipContent>\n                        <p>{tooltip || 'No puede firmar en este momento.'}</p>\n                    </TooltipContent>\n                )}\n            </Tooltip>\n           </TooltipProvider>\n        )}\n      </CardContent>\n\n      <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>\n        <DialogContent className=\"sm:max-w-md\">\n          <DialogHeader>\n            <DialogTitle>Realizar Firma Digital</DialogTitle>\n          </DialogHeader>\n          <SignaturePad onSave={handleSaveSignature} isSaving={isSaving} />\n        </DialogContent>\n      </Dialog>\n    </Card>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 913, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/badge.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n"],"names":[],"mappings":";;;;;AACA;AAEA;;;;AAEA,MAAM,gBAAgB,CAAA,GAAA,gKAAA,CAAA,MAAG,AAAD,EACtB,0KACA;IACE,UAAU;QACR,SAAS;YACP,SACE;YACF,WACE;YACF,aACE;YACF,SAAS;QACX;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAOF,SAAS,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAmB;IACzD,qBACE,8OAAC;QAAI,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,cAAc;YAAE;QAAQ,IAAI;QAAa,GAAG,KAAK;;;;;;AAExE","debugId":null}},
    {"offset": {"line": 955, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/permits/%5Bid%5D/components/StatusBadge.tsx"],"sourcesContent":["'use client';\nimport { Badge } from '@/components/ui/badge';\nimport type { PermitStatus } from '@/types';\n\ninterface StatusBadgeProps {\n  status: PermitStatus;\n}\n\nconst statusConfig: Record<PermitStatus, { text: string; color: string }> = {\n  borrador: { text: 'Borrador', color: 'bg-gray-100 text-gray-800' },\n  pendiente_revision: { text: 'Pendiente de Revisi√≥n', color: 'bg-yellow-100 text-yellow-800' },\n  aprobado: { text: 'Aprobado', color: 'bg-green-100 text-green-800' },\n  en_ejecucion: { text: 'En Ejecuci√≥n', color: 'bg-purple-100 text-purple-800' },\n  suspendido: { text: 'Suspendido', color: 'bg-orange-100 text-orange-800' },\n  cerrado: { text: 'Cerrado', color: 'bg-blue-100 text-blue-800' },\n  rechazado: { text: 'Rechazado', color: 'bg-red-100 text-red-800' },\n};\n\nexport function StatusBadge({ status }: StatusBadgeProps) {\n  const config = statusConfig[status] || statusConfig.borrador;\n  return <Badge className={config.color}>{config.text}</Badge>;\n}\n"],"names":[],"mappings":";;;;AACA;AADA;;;AAQA,MAAM,eAAsE;IAC1E,UAAU;QAAE,MAAM;QAAY,OAAO;IAA4B;IACjE,oBAAoB;QAAE,MAAM;QAAyB,OAAO;IAAgC;IAC5F,UAAU;QAAE,MAAM;QAAY,OAAO;IAA8B;IACnE,cAAc;QAAE,MAAM;QAAgB,OAAO;IAAgC;IAC7E,YAAY;QAAE,MAAM;QAAc,OAAO;IAAgC;IACzE,SAAS;QAAE,MAAM;QAAW,OAAO;IAA4B;IAC/D,WAAW;QAAE,MAAM;QAAa,OAAO;IAA0B;AACnE;AAEO,SAAS,YAAY,EAAE,MAAM,EAAoB;IACtD,MAAM,SAAS,YAAY,CAAC,OAAO,IAAI,aAAa,QAAQ;IAC5D,qBAAO,8OAAC,iIAAA,CAAA,QAAK;QAAC,WAAW,OAAO,KAAK;kBAAG,OAAO,IAAI;;;;;;AACrD","debugId":null}},
    {"offset": {"line": 1010, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/permits/actions.ts"],"sourcesContent":["\n\n'use server';\n\nimport { adminDb, isAdminReady } from '@/lib/firebase-admin';\nimport { revalidatePath } from 'next/cache';\nimport type { Permit, ExternalWorker, PermitStatus, PermitClosure, Approval, UserRole, AnexoAltura, AnexoConfinado, AnexoEnergias, AnexoExcavaciones, AnexoIzaje, AnexoATS, PermitGeneralInfo, JustificacionATS, ValidacionDiaria, User, Notification } from '@/types';\nimport { FieldValue, UpdateData, Timestamp } from 'firebase-admin/firestore';\nimport { sendWhatsAppNotification } from '@/lib/notifications';\nimport { getEmailForUser, sendPermitUpdateEmail } from '@/lib/email';\nimport { config } from 'dotenv';\nconfig();\n\n// --- Funciones Auxiliares para Notificaciones ---\n\nconst getInvolvedUsers = async (permit: Permit): Promise<string[]> => {\n  const userIds = new Set<string>();\n\n  // 1. Creador del permiso\n  if (permit.createdBy) {\n    userIds.add(permit.createdBy);\n  }\n\n  // 2. Usuarios que han firmado\n  Object.values(permit.approvals || {}).forEach(approval => {\n    if (approval && approval.userId) {\n      userIds.add(approval.userId);\n    }\n  });\n\n  // 3. Roles administrativos o de supervisi√≥n que deber√≠an ser notificados\n  const adminsQuery = await adminDb.collection('users').where('role', 'in', ['admin', 'autorizante', 'lider_sst']).get();\n  adminsQuery.forEach(doc => userIds.add(doc.id));\n\n  return Array.from(userIds);\n};\n\nconst createNotification = async (\n  userId: string,\n  permit: Permit,\n  message: string,\n  type: Notification['type'],\n  triggeredBy: { uid: string, displayName: string | null }\n) => {\n  const notification: Omit<Notification, 'id'> = {\n    userId,\n    permitId: permit.id,\n    permitNumber: permit.number || '',\n    message,\n    type,\n    isRead: false,\n    createdAt: FieldValue.serverTimestamp() as Timestamp,\n    triggeredBy,\n  };\n  await adminDb.collection('notifications').add(notification as any);\n  \n  // Enviar correo electr√≥nico\n  const userEmail = await getEmailForUser(userId);\n  if (userEmail) {\n    await sendPermitUpdateEmail({\n      to: userEmail,\n      subject: `Actualizaci√≥n en Permiso SGTC: ${permit.number || permit.id}`,\n      html: `<p>${message}</p><p>Puedes ver los detalles del permiso haciendo clic <a href=\"${process.env.NEXT_PUBLIC_BASE_URL}/permits/${permit.id}\">aqu√≠</a>.</p>`\n    });\n  }\n};\n\n// --- Fin de Funciones de Notificaciones ---\n\nconst workTypesMap: {[key: string]: string} = {\n  'alturas': 'Trabajo en Alturas',\n  'confinado': 'Espacios Confinados',\n  'energia': 'Control de Energ√≠as',\n  'izaje': 'Izaje de Cargas',\n  'excavacion': 'Excavaciones',\n  'general': 'Trabajo General'\n};\n\nconst getWorkTypesString = (permit: Partial<Permit>): string => {\n  const selectedTypes: string[] = [];\n  if (permit.trabajoAlturas) selectedTypes.push('Trabajo en Alturas');\n  if (permit.espaciosConfinados) selectedTypes.push('Espacios Confinados');\n  if (permit.controlEnergia) selectedTypes.push('Control de Energ√≠as');\n  if (permit.izajeCargas) selectedTypes.push('Izaje de Cargas');\n  if (permit.excavaciones) selectedTypes.push('Excavaciones');\n  \n  if (selectedTypes.length === 0) {\n    if (permit.trabajoGeneral) return 'Trabajo General';\n    // Fallback for old data structure\n    if (permit.workType && Array.isArray(permit.workType)) {\n      return permit.workType.map(key => workTypesMap[key] || key).join(', ');\n    }\n    return 'Trabajo General';\n  }\n  return selectedTypes.join(', ');\n};\n\nconst getStatusText = (status: string) => {\n    const statusText: {[key: string]: string} = {\n      'borrador': 'Borrador',\n      'pendiente_revision': 'Pendiente de Revisi√≥n',\n      'aprobado': 'Aprobado',\n      'en_ejecucion': 'En Ejecuci√≥n',\n      'suspendido': 'Suspendido',\n      'cerrado': 'Cerrado',\n      'rechazado': 'Rechazado'\n    };\n    return statusText[status] || status;\n  };\n\nconst signatureRoles: { [key in 'solicitante' | 'autorizante' | 'mantenimiento' | 'lider_sst' | 'coordinador_alturas']: string } = {\n  coordinador_alturas: 'COORDINADOR DE TRABAJOS EN ALTURAS',\n  solicitante: 'QUIEN SOLICITA (L√çDER A CARGO DEL EQUIPO EJECUTANTE)',\n  autorizante: 'QUIEN AUTORIZA (JEFES Y DUE√ëOS DE AREA)',\n  mantenimiento: 'PERSONAL DE MANTENIMIENTO',\n  lider_sst: 'Firma SST',\n};\n\ntype PermitCreateData = Omit<Permit, 'id' | 'createdAt' | 'status' | 'createdBy' | 'number' | 'user' | 'approvals' | 'closure'> & {\n  userId: string;\n  userDisplayName: string | null;\n  userEmail: string | null;\n  userPhotoURL: string | null;\n};\n\nexport async function createPermit(data: PermitCreateData) {\n  if (!data.userId) {\n    return { success: false, error: 'User not authenticated' };\n  }\n   if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const { userId, userDisplayName, userEmail, userPhotoURL, ...permitData } = data;\n\n  const initialApprovals = {\n    solicitante: { status: 'pendiente' as const },\n    autorizante: { status: 'pendiente' as const },\n    mantenimiento: { status: 'pendiente' as const },\n    lider_sst: { status: 'pendiente' as const },\n    coordinador_alturas: { status: 'pendiente' as const },\n  };\n\n  const permitPayload: Omit<Permit, 'id'> = {\n    ...permitData,\n    status: 'pendiente_revision' as const,\n    createdBy: userId,\n    createdAt: FieldValue.serverTimestamp() as Timestamp,\n    user: {\n      displayName: userDisplayName,\n      email: userEmail,\n      photoURL: userPhotoURL,\n    },\n    approvals: initialApprovals,\n    trabajoAlturas: data.trabajoAlturas || false,\n    isSSTSignatureRequired: data.isSSTSignatureRequired || false,\n    closure: {},\n  };\n  \n  try {\n    const docRef = await adminDb.collection('permits').add(permitPayload as any);\n    const permitNumber = `PT-${Date.now()}-${docRef.id.substring(0, 6).toUpperCase()}`;\n    await docRef.update({ number: permitNumber });\n    \n    console.log('‚úÖ [Action] Permiso creado con √©xito en Firestore:', docRef.id);\n\n    const createdPermit = { ...permitPayload, id: docRef.id, number: permitNumber } as Permit;\n    const involvedUsers = await getInvolvedUsers(createdPermit);\n    const message = `Se cre√≥ un nuevo permiso de trabajo: #${permitNumber}`;\n    \n    for (const uid of involvedUsers) {\n      if (uid !== userId) {\n        await createNotification(uid, createdPermit, message, 'creation', { uid: userId, displayName: userDisplayName });\n      }\n    }\n\n    const workTypesText = getWorkTypesString(permitPayload);\n    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n    const permitUrl = `${baseUrl}/permits/${docRef.id}`;\n    \n    const messageBody = `*¬°Alerta de Seguridad SGPT!* üö®\nSe ha creado una nueva solicitud de permiso de trabajo.\n\nüìÑ *N√∫mero:* ${permitNumber}\nüë§ *Solicitante:* ${userDisplayName || 'N/A'}\nüõ†Ô∏è *Tipo de Trabajo:* ${workTypesText}\n\nPor favor, revise la solicitud para su aprobaci√≥n en el siguiente enlace:\n${permitUrl}`;\n    \n    await sendWhatsAppNotification(messageBody);\n    \n    revalidatePath('/permits');\n    revalidatePath('/dashboard');\n    \n    return { success: true, permitId: docRef.id, permitNumber };\n  } catch (error: any) {\n    console.error(\"‚ùå [Action] Error al crear permiso:\", error);\n    return { \n      success: false, \n      error: error.message || 'Could not create permit. Please try again.' \n    };\n  }\n}\n\nexport async function savePermitDraft(data: PermitCreateData & { draftId?: string }) {\n  if (!data.userId) {\n    return { success: false, error: 'User not authenticated' };\n  }\n  if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const { userId, userDisplayName, userEmail, userPhotoURL, draftId, ...permitData } = data;\n\n  const initialApprovals = {\n    solicitante: { status: 'pendiente' as const },\n    autorizante: { status: 'pendiente' as const },\n    mantenimiento: { status: 'pendiente' as const },\n    lider_sst: { status: 'pendiente' as const },\n    coordinador_alturas: { status: 'pendiente' as const },\n  };\n\n  const permitPayload: Omit<Permit, 'id' | 'createdAt'> = {\n    ...permitData,\n    status: 'borrador' as const,\n    createdBy: userId,\n    user: {\n      displayName: userDisplayName,\n      email: userEmail,\n      photoURL: userPhotoURL,\n    },\n    approvals: initialApprovals,\n    trabajoAlturas: data.trabajoAlturas || false,\n    isSSTSignatureRequired: data.isSSTSignatureRequired || false,\n  };\n\n  try {\n    if (draftId) {\n      // Actualizar un borrador existente\n      const docRef = adminDb.collection('permits').doc(draftId);\n      await docRef.update({ ...permitPayload, updatedAt: FieldValue.serverTimestamp() });\n      revalidatePath(`/permits/${draftId}`);\n      revalidatePath('/permits');\n      return { success: true, permitId: draftId, isUpdate: true };\n    } else {\n      // Crear un nuevo borrador\n      const payloadWithTimestamp = { ...permitPayload, createdAt: FieldValue.serverTimestamp() };\n      const docRef = await adminDb.collection('permits').add(payloadWithTimestamp as any);\n      revalidatePath('/permits');\n      return { success: true, permitId: docRef.id, isUpdate: false };\n    }\n  } catch (error: any) {\n    console.error(\"‚ùå [Action] Error al guardar borrador:\", error);\n    return { \n      success: false, \n      error: error.message || 'Could not save draft. Please try again.' \n    };\n  }\n}\n\nexport async function addSignatureAndNotify(\n  permitId: string, \n  role: 'solicitante' | 'autorizante' | 'mantenimiento' | 'lider_sst' | 'coordinador_alturas' | 'cierre_autoridad' | 'cierre_responsable' | 'cancelacion', \n  signatureType: 'firmaApertura' | 'firmaCierre',\n  signatureDataUrl: string,\n  user: { uid: string, displayName: string | null, role?: UserRole, empresa?: string },\n  comments?: string\n) {\n    if (!permitId || !role || !user || !user.uid || !user.role) {\n        return { success: false, error: 'Par√°metros inv√°lidos para guardar la firma.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n    }\n\n    try {\n        const docRef = adminDb.collection('permits').doc(permitId);\n        const permitDocBefore = await docRef.get();\n        if (!permitDocBefore.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n        const permitBeforeData = permitDocBefore.data() as Permit;\n\n        const updateData: UpdateData<Permit> = {};\n\n        // L√≥gica para manejar firmas de cierre y cancelaci√≥n\n        if (role.startsWith('cierre_') || role === 'cancelacion') {\n            const closureRole = role === 'cierre_autoridad' ? 'autoridad' : (role === 'cierre_responsable' ? 'responsable' : 'canceladoPor');\n            const closurePath = `closure.${closureRole}`;\n            \n            const existingClosureData = (permitBeforeData.closure as any)?.[closureRole] || {};\n\n            updateData[closurePath as keyof UpdateData<Permit>] = {\n                ...existingClosureData,\n                firma: signatureDataUrl,\n                nombre: user.displayName,\n                fecha: FieldValue.serverTimestamp() \n            };\n            \n            if (role === 'cancelacion') {\n                updateData['closure.razonCancelacion'] = comments || 'No especificado';\n                updateData['closure.cancelado'] = 'si';\n            }\n\n        } else {\n            // ‚úÖ VALIDACI√ìN DE PERMISOS ANTES DE FIRMAR\n            const canSign = await validateSignaturePermission(permitId, role, user);\n            if (!canSign.allowed) {\n                return { success: false, error: canSign.reason };\n            }\n\n            const approvalData: Partial<Approval> = {\n                status: 'aprobado',\n                firmaApertura: signatureDataUrl,\n                userName: user.displayName,\n                userId: user.uid,\n                signedAt: FieldValue.serverTimestamp() as any,\n                userRole: user.role,\n                userEmpresa: user.empresa || 'N/A',\n                comments: comments || '',\n            }\n            \n            updateData[`approvals.${role}`] = approvalData;\n            \n            // ‚úÖ L√ìGICA DE FIRMAS SEG√öN EL ROL\n            if (signatureType === 'firmaApertura') {\n                const validationPayload: ValidacionDiaria = { \n                    dia: 1, \n                    nombre: user.displayName || '', \n                    firma: signatureDataUrl, \n                    fecha: new Date().toISOString() \n                };\n                \n                // ‚úÖ SOLICITANTE FIRMA: Cambia de Borrador a Pendiente de Revisi√≥n\n                if (role === 'solicitante') {\n                    if (permitBeforeData.status === 'borrador') {\n                        const permitNumber = `PT-${Date.now()}-${permitId.substring(0, 6).toUpperCase()}`;\n                        updateData['number'] = permitNumber;\n                        updateData['status'] = 'pendiente_revision';\n                    }\n                    \n                    // Validaci√≥n diaria inicial del responsable\n                    ['anexoAltura', 'anexoConfinado', 'anexoIzaje', 'anexoExcavaciones'].forEach(anexo => {\n                        if ((permitBeforeData as any)?.[anexo]) {\n                            const currentValidations = (permitBeforeData as any)[anexo].validacion?.responsable || [];\n                            if (!currentValidations[0]?.firma) {\n                                currentValidations[0] = validationPayload;\n                                updateData[`${anexo}.validacion.responsable`] = currentValidations;\n                            }\n                        }\n                    });\n\n                // ‚úÖ AUTORIZANTE FIRMA: Agrega validaci√≥n diaria de autoridad\n                } else if (role === 'autorizante') {\n                    ['anexoAltura', 'anexoConfinado', 'anexoIzaje', 'anexoExcavaciones'].forEach(anexo => {\n                        if ((permitBeforeData as any)?.[anexo]) {\n                           const currentValidations = (permitBeforeData as any)[anexo].validacion?.autoridad || [];\n                            if (!currentValidations[0]?.firma) {\n                                currentValidations[0] = validationPayload;\n                                updateData[`${anexo}.validacion.autoridad`] = currentValidations;\n                            }\n                        }\n                    });\n                }\n            }\n\n            // ‚úÖ VERIFICACI√ìN AUTOM√ÅTICA: ¬øTodas las firmas requeridas est√°n completas?\n            const updatedPermitData = { \n                ...permitBeforeData, \n                approvals: { ...permitBeforeData.approvals, [role]: approvalData }\n            };\n            \n            if (await checkAllRequiredSignaturesComplete(updatedPermitData)) {\n                // üöÄ CAMBIO AUTOM√ÅTICO DE PENDIENTE_REVISION ‚Üí EN_EJECUCION\n                if (permitBeforeData.status === 'pendiente_revision') {\n                    updateData['status'] = 'en_ejecucion';\n                }\n            }\n        }\n        \n        await docRef.update(updateData);\n        \n        const permitDoc = await docRef.get();\n        const updatedPermitData = { id: permitDoc.id, ...permitDoc.data() } as Permit;\n        \n        const signatureRoleName = (signatureRoles as any)[role] || role.replace('_', ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n        \n        const message = `${user.displayName || 'Un usuario'} ha firmado el permiso #${updatedPermitData.number} como ${signatureRoleName}.`;\n        const involvedUsers = await getInvolvedUsers(updatedPermitData);\n        \n        for (const uid of involvedUsers) {\n          if (uid !== user.uid) {\n            await createNotification(uid, updatedPermitData, message, 'signature', user);\n          }\n        }\n        \n        // ‚úÖ NOTIFICACI√ìN ESPECIAL SI EL PERMISO PAS√ì AUTOM√ÅTICAMENTE A EN_EJECUCION\n        if (updateData['status'] === 'en_ejecucion') {\n            const executionMessage = `El permiso #${updatedPermitData.number} ha completado todas las aprobaciones requeridas y ahora est√° EN EJECUCI√ìN.`;\n            for (const uid of involvedUsers) {\n                 await createNotification(uid, updatedPermitData, executionMessage, 'approval', user);\n            }\n            \n            // Notificaci√≥n WhatsApp\n            const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n            const permitUrl = `${baseUrl}/permits/${permitId}`;\n            const whatsappMsg = `*¬°PERMISO EN EJECUCI√ìN!* ‚úÖ\n\nüìÑ *N√∫mero:* ${updatedPermitData.number}\nüìç *√Årea:* ${permitBeforeData.generalInfo?.areaEspecifica || 'N/A'}\nüõ†Ô∏è *Tipo:* ${getWorkTypesString(permitBeforeData)}\n\n‚úÖ Todas las firmas requeridas han sido completadas.\nEl permiso est√° ahora EN EJECUCI√ìN.\n\nVer detalles: ${permitUrl}`;\n            \n            await sendWhatsAppNotification(whatsappMsg);\n        }\n\n        revalidatePath(`/permits/${permitId}`);\n        return { success: true };\n\n    } catch (error: any) {\n        console.error(\"‚ùå Error al guardar firma y notificar:\", error);\n        return {\n            success: false,\n            error: error.message || 'No se pudo guardar la firma.'\n        };\n    }\n}\n\n// ‚úÖ FUNCI√ìN CORREGIDA: Verificar si todas las firmas requeridas est√°n completas\nasync function checkAllRequiredSignaturesComplete(\n  permitData: Permit\n): Promise<boolean> {\n    const { approvals } = permitData;\n    \n    // Firma del solicitante es SIEMPRE requerida\n    if (approvals?.solicitante?.status !== 'aprobado') {\n        return false;\n    }\n    \n    // Firma del autorizante es SIEMPRE requerida\n    if (approvals?.autorizante?.status !== 'aprobado') {\n        return false;\n    }\n    \n    // Si hay trabajos en alturas, requiere firma del coordinador\n    if (permitData.trabajoAlturas || permitData.selectedWorkTypes?.alturas) {\n        if (approvals?.coordinador_alturas?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    // Si hay control de energ√≠a, requiere firma de mantenimiento\n    if (permitData.controlEnergia) {\n        if (approvals?.mantenimiento?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    // Si SST es requerido, validar su firma\n    if (permitData.isSSTSignatureRequired) {\n        if (approvals?.lider_sst?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n// ‚úÖ FUNCI√ìN MEJORADA: Validaci√≥n de transiciones de estado\nfunction validateStateTransition(currentStatus: PermitStatus, targetStatus: PermitStatus, userRole: UserRole): { allowed: boolean, reason?: string } {\n    const allowedTransitions: Partial<Record<PermitStatus, Partial<Record<PermitStatus, UserRole[]>>>> = {\n        'borrador': {\n            'pendiente_revision': ['solicitante', 'lider_tarea', 'admin']\n        },\n        'pendiente_revision': {\n            'en_ejecucion': ['autorizante', 'admin'],\n            'rechazado': ['autorizante', 'lider_sst', 'admin']\n        },\n        'en_ejecucion': {\n            'suspendido': ['lider_sst', 'admin'],\n            'cerrado': ['lider_tarea', 'autorizante', 'admin']\n        },\n        'suspendido': {\n            'en_ejecucion': ['lider_sst', 'admin'],\n            'cerrado': ['lider_tarea', 'autorizante', 'admin']\n        },\n        // Mantener compatibilidad con permisos antiguos que tengan estado \"aprobado\"\n        'aprobado': {\n            'en_ejecucion': ['lider_tarea', 'admin'],\n            'rechazado': ['autorizante', 'lider_sst', 'admin']\n        }\n    };\n    \n    const allowedRoles = allowedTransitions[currentStatus]?.[targetStatus];\n    if (!allowedRoles) {\n        return { allowed: false, reason: `Transici√≥n de '${currentStatus}' a '${targetStatus}' no est√° permitida.` };\n    }\n\n    if (!allowedRoles.includes(userRole) && userRole !== 'admin') {\n        return { allowed: false, reason: `Tu rol (${userRole}) no tiene permisos para cambiar el estado a '${targetStatus}'.` };\n    }\n\n    return { allowed: true };\n}\n\nexport async function updatePermitStatus(\n  permitId: string,\n  status: PermitStatus,\n  currentUser: { uid: string, displayName: string | null, role?: UserRole },\n  reason?: string\n) {\n    if (!permitId || !currentUser.uid || !currentUser.role) {\n        return { success: false, error: 'Par√°metros inv√°lidos o usuario sin rol.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas.' };\n    }\n\n    try {\n        const docRef = adminDb.collection('permits').doc(permitId);\n        const permitSnap = await docRef.get();\n        if (!permitSnap.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n        const permitData = permitSnap.data() as Permit;\n        \n        // ‚úÖ Validar transici√≥n de estado\n        const transition = validateStateTransition(permitData.status, status, currentUser.role);\n        if (!transition.allowed) {\n            return { success: false, error: transition.reason };\n        }\n\n        const updateData: UpdateData<Permit> = { status };\n\n        // ‚úÖ Guardar raz√≥n de rechazo\n        if (status === 'rechazado' && reason) {\n            updateData.rejectionReason = reason;\n        }\n        \n        // ‚úÖ Marcar fecha de cierre\n        if (status === 'cerrado') {\n            updateData['closure.fechaCierre'] = FieldValue.serverTimestamp();\n            updateData['closure.terminado'] = 'si';\n        }\n\n        await docRef.update(updateData);\n        \n        const updatedPermitData = { ...permitData, ...updateData, id: permitId } as Permit;\n        const triggeredBy = currentUser;\n        \n        let notificationType: Notification['type'] = 'status_change';\n        let message = `${currentUser.displayName || 'Un usuario'} ha cambiado el estado del permiso #${permitData.number} a: ${getStatusText(status)}.`;\n\n        if (status === 'en_ejecucion') {\n            notificationType = 'approval';\n            message = `El permiso #${permitData.number} ha sido puesto EN EJECUCI√ìN manualmente.`;\n        } else if (status === 'rechazado') {\n            notificationType = 'rejection';\n            message = `${currentUser.displayName || 'Un usuario'} ha rechazado el permiso #${permitData.number}.`;\n            if (reason) message += ` Motivo: ${reason}`;\n        } else if (status === 'cerrado') {\n            notificationType = 'cancellation';\n            message = `${currentUser.displayName || 'Un usuario'} ha cerrado el permiso #${permitData.number}.`;\n        }\n        \n        const involvedUsers = await getInvolvedUsers(updatedPermitData);\n        for (const uid of involvedUsers) {\n             if (uid !== currentUser.uid) {\n                await createNotification(uid, updatedPermitData, message, notificationType, triggeredBy);\n            }\n        }\n\n        const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n        const permitUrl = `${baseUrl}/permits/${permitId}`;\n\n        let messageBody = `*Actualizaci√≥n de Estado - SGTC* üîÑ\nEl estado del permiso *${permitData.number || permitId}* ha cambiado.\n\n*Nuevo Estado:* ${getStatusText(status)}\n\nPuede ver los detalles aqu√≠:\n${permitUrl}`;\n\n        if (status === 'rechazado' && reason) {\n          messageBody += `\\n\\n*Motivo del rechazo:* ${reason}`;\n        }\n        \n        await sendWhatsAppNotification(messageBody);\n        \n        revalidatePath(`/permits/${permitId}`);\n        revalidatePath('/permits');\n        revalidatePath('/dashboard');\n\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"‚ùå Error updating permit status:\", error);\n        return {\n            success: false,\n            error: error.message || 'Could not update permit status.'\n        };\n    }\n}\n\n// ‚úÖ FUNCI√ìN MEJORADA: Validaci√≥n de permisos de firma con orden jer√°rquico\nasync function validateSignaturePermission(\n    permitId: string, \n    signatureRole: string, \n    currentUser: { uid: string, role?: UserRole }\n): Promise<{ allowed: boolean, reason?: string }> {\n    const docRef = adminDb.collection('permits').doc(permitId);\n    const permitDoc = await docRef.get();\n    if (!permitDoc.exists) {\n        return { allowed: false, reason: 'Permiso no encontrado.' };\n    }\n    const permit = permitDoc.data() as Permit;\n    \n    // ‚úÖ Verificar que el permiso est√© en un estado v√°lido para firmar\n    if (!['borrador', 'pendiente_revision'].includes(permit.status)) {\n        return { allowed: false, reason: `No se puede firmar un permiso en estado '${permit.status}'.` };\n    }\n    \n    switch (signatureRole) {\n        case 'coordinador_alturas':\n            // Debe haber trabajo en alturas\n            if (!permit.trabajoAlturas && !permit.selectedWorkTypes?.alturas) {\n                return { allowed: false, reason: 'Esta firma solo aplica para trabajos en alturas.' };\n            }\n            // Solo el creador o admin puede gestionar esta firma\n            if (permit.createdBy !== currentUser.uid && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Solo el creador del permiso puede gestionar esta firma.' };\n            }\n            break;\n            \n        case 'solicitante':\n            if (permit.createdBy !== currentUser.uid && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Solo el creador del permiso puede firmar como solicitante.' };\n            }\n            // ‚úÖ Si hay anexo de alturas, verificar firma del coordinador primero\n            if ((permit.trabajoAlturas || permit.selectedWorkTypes?.alturas) && \n                permit.approvals?.coordinador_alturas?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del Coordinador de Trabajos en Alturas.' };\n            }\n            break;\n            \n        case 'autorizante':\n            if (currentUser.role !== 'autorizante' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de autorizante requerido para esta firma.' };\n            }\n            if (permit.approvals?.solicitante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del solicitante.' };\n            }\n            break;\n            \n        case 'lider_sst':\n            if (currentUser.role !== 'lider_sst' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de L√≠der SST requerido para esta firma.' };\n            }\n            // ‚úÖ Solo requerido si isSSTSignatureRequired es true\n            if (!permit.isSSTSignatureRequired) {\n                return { allowed: false, reason: 'Firma de SST no es requerida para este permiso.' };\n            }\n            if (permit.approvals?.solicitante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del solicitante.' };\n            }\n            break;\n            \n        case 'mantenimiento':\n             if (currentUser.role !== 'mantenimiento' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de Mantenimiento requerido para esta firma.' };\n            }\n            if (!permit.controlEnergia) {\n                return { allowed: false, reason: 'Firma de Mantenimiento solo aplica cuando hay control de energ√≠as.' };\n            }\n            if (permit.approvals?.autorizante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del autorizante.' };\n            }\n            break;\n    }\n    \n    return { allowed: true };\n}\n\nexport async function addDailyValidationSignature(\n  permitId: string, \n  anexoName: string, \n  validationType: 'autoridad' | 'responsable', \n  index: number, \n  data: ValidacionDiaria, \n  user: User\n) {\n  if (!permitId || !anexoName || !validationType || index < 0 || !data || !user) {\n    return { success: false, error: 'Par√°metros inv√°lidos.' };\n  }\n\n  if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const docRef = adminDb.collection('permits').doc(permitId);\n  try {\n    const permitSnap = await docRef.get();\n    if (!permitSnap.exists) {\n      return { success: false, error: 'El permiso no existe.' };\n    }\n    const permitData = permitSnap.data() as Permit;\n\n    // ‚úÖ Verificar que el permiso est√© en ejecuci√≥n para validaciones diarias\n    if (!['en_ejecucion', 'suspendido'].includes(permitData.status)) {\n        return { success: false, error: 'Solo se pueden agregar validaciones diarias en permisos EN EJECUCI√ìN o SUSPENDIDOS.' };\n    }\n\n    const anexoData = (permitData as any)[anexoName];\n    if (!anexoData) {\n      return { success: false, error: `El anexo ${anexoName} no existe en el permiso.` };\n    }\n    \n    const anexoUpdate: any = { ...anexoData };\n    if (!anexoUpdate.validacion) {\n        anexoUpdate.validacion = { autoridad: [], responsable: [] };\n    }\n\n    const validationArray = (anexoUpdate.validacion[validationType] as ValidacionDiaria[]) || [];\n    \n    while (validationArray.length <= index) {\n        validationArray.push({ dia: validationArray.length + 1, nombre: '', fecha: '', firma: '' });\n    }\n\n    validationArray[index] = data;\n    \n    const updatePath = `${anexoName}.validacion.${validationType}`;\n    \n    await docRef.update({\n      [updatePath]: validationArray,\n    });\n\n    const fullPermitData = { id: docRef.id, ...permitData } as Permit;\n    const anexoDisplayName = anexoName.replace('anexo', 'Anexo ');\n    const validationRoleName = validationType === 'autoridad' ? 'Autoridad del √Årea' : 'Responsable del Trabajo';\n    const day = index + 1;\n\n    const message = `${user.displayName || 'Un usuario'} ha realizado la validaci√≥n diaria (${validationRoleName}) para el D√çA ${day} del ${anexoDisplayName} en el permiso #${fullPermitData.number}.`;\n    const involvedUsers = await getInvolvedUsers(fullPermitData);\n    for (const uid of involvedUsers) {\n      if (uid !== user.uid) {\n        await createNotification(uid, fullPermitData, message, 'status_change', { uid: user.uid, displayName: user.displayName || null });\n      }\n    }\n\n    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n    const permitUrl = `${baseUrl}/permits/${permitId}`;\n    const whatsappMessage = `*Validaci√≥n Diaria - SGTC* ‚úçÔ∏è\nSe ha registrado una nueva firma de validaci√≥n diaria.\n\nüìÑ *Permiso:* ${fullPermitData.number || 'N/A'}\nüóìÔ∏è *D√≠a:* ${day}\nüë§ *Firmante:* ${user.displayName || 'N/A'}\n‚úÖ *Rol:* ${validationRoleName}\nüìã *Anexo:* ${anexoDisplayName}\n\nPuede ver los detalles aqu√≠:\n${permitUrl}`;\n    \n    await sendWhatsAppNotification(whatsappMessage);\n\n    revalidatePath(`/permits/${permitId}`);\n    return { success: true };\n\n  } catch (error: any) {\n    console.error(\"‚ùå Error al guardar la validaci√≥n diaria:\", error);\n    return { success: false, error: 'No se pudo guardar la firma de validaci√≥n.' };\n  }\n}\n\nexport async function addWorkerSignature(permitId: string, workerIndex: number, signatureType: 'firmaApertura' | 'firmaCierre', signatureDataUrl: string) {\n    if (!permitId || workerIndex < 0 || !signatureType || !signatureDataUrl) {\n        return { success: false, error: 'Faltan par√°metros.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n    }\n\n    const docRef = adminDb.collection('permits').doc(permitId);\n    try {\n        const permitSnap = await docRef.get();\n        if (!permitSnap.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n\n        const permitData = permitSnap.data() as Permit;\n        \n        // ‚úÖ CORRECCI√ìN: Validaci√≥n de estado corregida para firma de apertura\n        if (signatureType === 'firmaApertura' && !['pendiente_revision', 'aprobado', 'en_ejecucion'].includes(permitData.status)) {\n            return { success: false, error: 'Solo se puede firmar apertura cuando el permiso est√° pendiente, aprobado o en ejecuci√≥n.' };\n        }\n        if (signatureType === 'firmaCierre' && !['en_ejecucion', 'suspendido'].includes(permitData.status)) {\n            return { success: false, error: 'Solo se puede firmar cierre en permisos EN EJECUCI√ìN o SUSPENDIDOS.' };\n        }\n        \n        const workers = permitData.workers ? [...permitData.workers] : [];\n\n        if (workerIndex >= workers.length) {\n            return { success: false, error: '√çndice de trabajador inv√°lido.' };\n        }\n\n        const signatureField = signatureType === 'firmaApertura' ? 'firmaApertura' : 'firmaCierre';\n        const dateField = signatureType === 'firmaApertura' ? 'fechaFirmaApertura' : 'fechaFirmaCierre';\n\n        workers[workerIndex] = {\n            ...workers[workerIndex],\n            [signatureField]: signatureDataUrl,\n            [dateField]: new Date().toISOString(), \n        };\n\n        await docRef.update({ workers: workers });\n\n        revalidatePath(`/permits/${permitId}`);\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"Error al guardar la firma del trabajador:\", error);\n        return { success: false, error: 'No se pudo guardar la firma.' };\n    }\n}\n"],"names":[],"mappings":";;;;;;IA8fsB,qBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 1031, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/pdf-generator.ts"],"sourcesContent":["// ‚úÖ Archivo: lib/pdf-generator.ts\nimport jsPDF from 'jspdf';\nimport autoTable from 'jspdf-autotable';\nimport { format, parseISO, isValid, differenceInCalendarDays } from 'date-fns';\n\n// Funci√≥n para renderizar checkmark, X o N/A\nconst getStatusSymbol = (value: string | boolean | undefined): string => {\n  if (value === 'si' || value === true) return '‚úì S√ç';\n  if (value === 'no' || value === false) return '‚úó NO';\n  if (value === 'na') return 'N/A';\n  return '‚Äî';\n};\n\nconst getStatusColor = (value: string | boolean | undefined): number[] => {\n  if (value === 'si' || value === true) return [34, 139, 34]; // Verde\n  if (value === 'no' || value === false) return [220, 20, 60]; // Rojo\n  if (value === 'na') return [169, 169, 169]; // Gris\n  return [0, 0, 0]; // Negro\n};\n\n// Definiciones de campos por secci√≥n\nexport const PELIGROS_VERIFICACION = [\n  { id: 'fisicos', label: 'F√≠sicos', seccion: 'verificacionPeligros' },\n  { id: 'quimicos', label: 'Qu√≠micos', seccion: 'verificacionPeligros' },\n  { id: 'biologicos', label: 'Biol√≥gicos', seccion: 'verificacionPeligros' },\n  { id: 'seguridad', label: 'De Seguridad', seccion: 'verificacionPeligros' },\n  { id: 'locativos', label: 'Locativos', seccion: 'verificacionPeligros' },\n  { id: 'biomecanico', label: 'Biomec√°nico', seccion: 'verificacionPeligros' },\n  { id: 'psicosocial', label: 'Psicosocial', seccion: 'verificacionPeligros' },\n];\n\nexport const ANEXO_ALTURA_CAMPOS = [\n  { id: 'afiliacionVigente', label: 'A. EL PERSONAL EJECUTANTE DE LA ACTIVIDAD TIENE LA AFILIACI√ìN VIGENTE A SEGURIDAD SOCIAL?' },\n  { id: 'procedimientoActividad', label: 'B. SE CUENTA CON EL PROCEDIMIENTO DE LA ACTIVIDAD A EJECUTAR?' },\n  { id: 'medidasPrevencion', label: 'C. SE HAN DETERMINADO LAS MEDIDAS DE PREVENCI√ìN CONTRA CA√çDAS?' },\n  { id: 'conocenMedidas', label: 'D. TODOS LOS EJECUTANTES CONOCEN LAS MEDIDAS DE PRECAUCI√ìN ESTABLECIDAS EN LA EVALUACI√ìN DE RIESGOS?' },\n  { id: 'entrenadosCertificados', label: 'E. EST√ÅN LOS EJECUTANTES ENTRENADOS Y SE ENCUENTRAN LOS CERTIFICADOS EN SITIO PARA REALIZAR TRABAJOS EN ALTURA?' },\n  { id: 'elementosProteccionCertificados', label: 'F. EST√ÅN TODOS LOS ELEMENTOS DE PROTECCI√ìN CONTRA CA√çDAS EN BUEN ESTADO Y CERTIFICADOS?' },\n  { id: 'sistemaAseguramientoVerificado', label: 'G. SE VERIFICO EL SISTEMA DE ASEGURAMIENTO DE LA ESCALERA, ANDAMIO O PLATAFORMA A UNA ESTRUCTURA FIJA' },\n  { id: 'estadoElementosVerificado', label: 'H. SE VERIFICO EL ESTADO DE: ESLINGAS, ARNES, CASCO, MOSQUETONES, Y DEMAS ELEMENTOS NECESARIOS' },\n  { id: 'puntosAnclajeCertificados', label: 'I. LOS PUNTOS DE ANCLAJE CUMPLEN CON LA RESISTENCIA DE 5000 LBS POR PERSONA Y ESTAN CERTIFICADOS?' },\n  { id: 'areaDelimitada', label: 'J. ESTA DELIMITADA Y SE√ëALIZADA EL AREA DE TRABAJO' },\n  { id: 'personalSaludable', label: 'K. EL PERSONAL QUE REALIZA EL TRABAJO SE ENCUENTRA EN CONDICIONES ADECUADAS DE SALUD?' },\n  { id: 'equiposAccesoBuenEstado', label: 'L. SE CUENTA CON TODOS LOS EQUIPOS Y SISTEMAS DE ACCESO PARA TRABAJO EN ALTURAS EN BUEN ESTADO?' },\n  { id: 'espacioCaidaLibreSuficiente', label: 'M. EL ESPACIO DE CAIDA LIBRE ES SUFICIENTE PARA EVITAR QUE LA PERSONA SE GOLPEE?' },\n  { id: 'equiposEmergenciaDisponibles', label: 'N. SE CUENTA CON ELEMENTOS PARA ATENCION DE EMERGENCIAS Y PLAN DE RESCATE EN ALTURAS?' },\n  { id: 'eppSeleccionadosCorrectamente', label: 'O. EST√ÅN LOS ELEMENTOS DE PROTECCI√ìN PERSONAL SELECCIONADOS CORRECTAMENTE?' },\n  { id: 'plataformaSoportaCarga', label: 'P. LA PLATAFORMA O ESTRUCTURA SOPORTA LA CARGA DE TRABAJO?' },\n  { id: 'supervisorConstante', label: 'Q. EXISTE UN SUPERVISOR O ACOMPA√ëANTE CONSTANTE DURANTE EL TRABAJO' },\n  { id: 'andamiosCompletos', label: 'R. EN CASO DE TRABAJOS SOBRE ANDAMIOS, ESTOS ESTAN COMPLETOS Y ADECUADAMENTE ARMADOS' },\n  { id: 'condicionesClimaticasAdecuadas', label: 'S. LAS CONDICIONES CLIMATICAS SON ADECUADAS PARA REALIZAR EL TRABAJO' },\n  { id: 'metodoSubirHerramientasSeguro', label: 'T. EL METODO DE SUBIR HERRAMIENTAS ES SEGURO' },\n];\n\nexport const ANEXO_CONFINADO_CAMPOS = [\n  { id: 'fuentesEnergiaAisladas', label: 'A. ESTAN LAS FUENTES DE ENERGIA AISLADAS' },\n  { id: 'ejecutantesConocenMedidas', label: 'B. TODOS LOS EJECUTANTES CONOCEN LAS MEDIDAS DE PRECAUCI√ìN ESTABLECIDAS?' },\n  { id: 'ejecutantesEntrenados', label: 'C. EST√ÅN LOS EJECUTANTES ENTRENADOS' },\n  { id: 'entradasSalidasFlujoBloqueadas', label: 'D. ESTAN BLOQUEADAS LAS ENTRADAS Y SALIDAS DE FLUJO' },\n  { id: 'areaDelimitada', label: 'E. ESTA DELIMITADA Y SE√ëALIZADA EL AREA DE TRABAJO' },\n  { id: 'monitorAtmosferasCalibrado', label: 'F. SE TIENE EN SITIO UN MONITOR DE ATMOSFERAS PELIGROSAS, CALIBRADO' },\n  { id: 'equiposIluminacionExplosion', label: 'G. SON A PRUEBA DE EXPLOSION LOS EQUIPOS DE ILUMINACION' },\n  { id: 'equiposVentilacionExplosion', label: 'H. SON A PRUEBA DE EXPLOSION LOS EQUIPOS DE VENTILACION' },\n  { id: 'equiposVentilacionSuficientes', label: 'J. LOS EQUIPOS DE VENTILACION ESTAN DISPONIBLES Y SON SUFICIENTES' },\n  { id: 'equiposRespiracionAutonoma', label: 'K. ESTAN DISPONIBLES EQUIPOS DE RESPIRACION AUTONOMA EN CASO DE EMERGENCIA' },\n  { id: 'elementosAtencionEmergencias', label: 'L. SE CUENTA CON ELEMENTOS PARA ATENCION DE EMERGENCIAS' },\n  { id: 'planEmergenciaRescate', label: 'M. SE CUENTA CON PLAN DE EMERGENCIA PARA RESCATE' },\n  { id: 'hojasSeguridadDisponibles', label: 'N. ESTAN DISPONIBLES LAS HOJAS DE SEGURIDAD DE PRODUCTOS QUIMICOS' },\n  { id: 'vigiaPermanente', label: 'O. SE VERIFICA QUE HAYA UN VIGIA PERMANENTE EN EL AREA' },\n  { id: 'herramientasAdecuadas', label: 'P. SE VERIFICO QUE LAS HERRAMIENTAS SEAN LAS ADECUADAS' },\n  { id: 'personalSaludable', label: 'Q. EL PERSONAL SE ENCUENTRA EN CONDICIONES ADECUADAS DE SALUD' },\n  { id: 'verificadoEpp', label: 'R. SE VERIFICO EL EQUIPO Y ELEMENTOS DE PROTECCION PERSONAL' },\n];\n\nexport const ANEXO_ENERGIA_CAMPOS = [\n  { id: 'fuentesEnergiaIdentificadas', label: 'A. SE HAN IDENTIFICADO LAS FUENTES DE ENERG√çA' },\n  { id: 'ejecutantesConocenMedidas', label: 'B. SE HAN IDENTIFICADO LOS EJECUTANTES Y LOS SUPERVISORES QUE DEBEN ESTAR PRESENTES' },\n  { id: 'medidasPrevencion', label: 'C. SE HAN DETERMINADO LAS MEDIDAS DE PREVENCI√ìN' },\n  { id: 'ejecutantesEntrenados', label: 'D. LOS EJECUTANTES EST√ÅN ENTRENADOS' },\n  { id: 'procedimientoDisiparEnergia', label: 'E. SE HA ESTABLECIDO EL PROCEDIMIENTO PARA DISIPAR ENERG√çA' },\n  { id: 'bloqueoEtiquetado', label: 'F. SE CUENTA CON BLOQUEOS Y ETIQUETADOS' },\n  { id: 'verificacionAusenciaEnergia', label: 'G. SE HA VERIFICADO LA AUSENCIA DE ENERG√çA' },\n  { id: 'distanciasSeguridad', label: 'H. SE CUMPLEN LAS DISTANCIAS DE SEGURIDAD SEG√öN RETIE' },\n];\n\nexport const ANEXO_IZAJE_CAMPOS = [\n  { id: 'terrenoEstabilizado', label: 'A. TERRENO ESTABILIZADO Y SOPORTA EL EQUIPO' },\n  { id: 'operadorVisualiza', label: 'B. OPERADOR VISUALIZA BIEN EL √ÅREA' },\n  { id: 'calculoTecnicoIzaje', label: 'C. SE CUENTA CON C√ÅLCULO T√âCNICO/PLAN DE IZAJE' },\n  { id: 'areaSe√±alizada', label: 'D. √ÅREA SE√ëALIZADA Y DEMARCADA' },\n  { id: 'verificacionCapacidad', label: 'E. SE VERIFIC√ì LA CAPACIDAD DEL EQUIPO VS CARGA' },\n  { id: 'areaLimpia', label: 'F. √ÅREA DE IZAJE DESPEJADA DE PERSONAL' },\n  { id: 'comunicacionClara', label: 'G. COMUNICACI√ìN CLARA ESTABLECIDA' },\n  { id: 'atsRealizado', label: 'H. ATS REALIZADO' },\n  { id: 'eslinguasEstado', label: 'I. ESLINGAS Y APAREJOS EN BUEN ESTADO' },\n  { id: 'polinesEstado', label: 'J. POLINES EN BUEN ESTADO' },\n  { id: 'polinesEstables', label: 'K. POLINES ESTABLES Y CORRECTAMENTE POSICIONADOS' },\n  { id: 'distanciaLineasElectricas', label: 'L. DISTANCIA SEGURA DE L√çNEAS EL√âCTRICAS' },\n  { id: 'sinPersonasAjoBajoCarga', label: 'M. SIN PERSONAS BAJO LA CARGA' },\n  { id: 'climaSeguro', label: 'N. CONDICIONES CLIM√ÅTICAS SEGURAS' },\n  { id: 'equipoTierra', label: 'O. EQUIPO CON CONEXI√ìN A TIERRA' },\n  { id: 'noMaterialCayendoCarga', label: 'P. SIN MATERIAL QUE PUEDA CAER SOBRE LA CARGA' },\n  { id: 'senalizadorCapacitado', label: 'Q. SE√ëALIZADOR CAPACITADO Y ENTRENADO' },\n  { id: 'afiliacionVerificada', label: 'R. SE VERIFIC√ì AFILIACI√ìN A SISTEMA DE SEGURIDAD SOCIAL' },\n];\n\nexport const ANEXO_EXCAVACION_CAMPOS = [\n  { id: 'sistemasEnterrados', label: 'A. SISTEMAS ENTERRADOS IDENTIFICADOS' },\n  { id: 'metodoExcavacion', label: 'B. M√âTODO DE EXCAVACI√ìN DETERMINADO' },\n  { id: 'ejecutantesEntrenados', label: 'C. EJECUTANTES ENTRENADOS' },\n  { id: 'controlEntibado', label: 'D. CONTROLES, ENTIBADO, SISTEMAS DE ACCESO INSTALADOS' },\n  { id: 'areaSe√±alizada', label: 'E. √ÅREA SE√ëALIZADA PARA PREVENIR CA√çDAS' },\n  { id: 'puentesComplementarios', label: 'F. PUENTES O PASARELAS SI NECESARIO' },\n  { id: 'materialesAlBorde', label: 'G. MATERIALES MOVIDOS A M√çNIMO 1M DEL BORDE' },\n  { id: 'escaleraSobresale', label: 'H. ESCALERAS SOBRESALEN M√çNIMO 1M DEL BORDE' },\n  { id: 'metodoRelleno', label: 'I. M√âTODO DE RELLENO PREVISTO' },\n];\n\n// Funci√≥n principal para generar PDF completo\nexport const generateCompleteWorkPermitPDF = async (permit: any) => {\n  const doc = new jsPDF('p', 'mm', 'letter');\n  const pageWidth = doc.internal.pageSize.width;\n  const pageHeight = doc.internal.pageSize.height;\n  const margin = 10;\n  let yPos = margin;\n\n  const italcolOrange = [239, 123, 0];\n\n  const checkPageBreak = (neededHeight: number) => {\n    if (yPos + neededHeight > pageHeight - margin) {\n      doc.addPage();\n      yPos = margin;\n    }\n  };\n\n  const drawHeader = (title: string) => {\n    doc.setFillColor(italcolOrange[0], italcolOrange[1], italcolOrange[2]);\n    doc.rect(margin, yPos, pageWidth - 2 * margin, 6, 'F');\n    doc.setTextColor(255, 255, 255);\n    doc.setFontSize(9);\n    doc.setFont('helvetica', 'bold');\n    doc.text(title.toUpperCase(), pageWidth / 2, yPos + 4, { align: 'center' });\n    doc.setTextColor(0, 0, 0);\n    yPos += 8;\n  };\n\n  const renderFieldsTable = (fields: any[], data: any, title: string) => {\n    checkPageBreak(50);\n    drawHeader(title);\n\n    const bodyData = fields.map(field => [\n      field.label,\n      getStatusSymbol(data[field.id]),\n      ''\n    ]);\n\n    autoTable(doc, {\n      startY: yPos,\n      head: [['DESCRIPCI√ìN', 'ESTADO', '']],\n      body: bodyData,\n      theme: 'grid',\n      headStyles: { fillColor: [240, 240, 240], textColor: [0, 0, 0], fontSize: 7 },\n      bodyStyles: { fontSize: 6, cellPadding: 1.5 },\n      columnStyles: {\n        0: { cellWidth: 120 },\n        1: { halign: 'center', cellWidth: 25, textColor: getStatusColor(data[fields[0].id]) },\n        2: { cellWidth: 10 }\n      },\n      didDrawCell: (data) => {\n        if (data.section === 'body' && data.column.index === 1) {\n          const fieldValue = fields[data.row.index]?.id;\n          const value = values[fieldValue];\n          const color = getStatusColor(value);\n          doc.setTextColor(color[0], color[1], color[2]);\n        }\n      }\n    });\n\n    yPos = (doc as any).lastAutoTable.finalY + 5;\n  };\n\n  // ===== CONTENIDO DEL PDF =====\n\n  // Encabezado principal\n  doc.setFontSize(14);\n  doc.setFont('helvetica', 'bold');\n  doc.text('PERMISO DE TRABAJO', pageWidth / 2, yPos, { align: 'center' });\n  yPos += 10;\n\n  // Informaci√≥n General\n  drawHeader('INFORMACI√ìN GENERAL DEL PERMISO');\n  autoTable(doc, {\n    startY: yPos,\n    body: [\n      ['N√∫mero Permiso:', permit.number || permit.id.substring(0, 8), 'Empresa:', permit.generalInfo?.empresa || ''],\n      ['Planta:', permit.generalInfo?.planta || '', '√Årea:', permit.generalInfo?.areaEspecifica || ''],\n      ['Proceso:', permit.generalInfo?.proceso || '', 'Contrato:', permit.generalInfo?.contrato || ''],\n      ['V√°lido Desde:', format(parseISO(permit.generalInfo?.validFrom), 'dd/MM/yy HH:mm'), 'V√°lido Hasta:', format(parseISO(permit.generalInfo?.validUntil), 'dd/MM/yy HH:mm')],\n      ['Solicitante:', permit.user?.displayName || '', 'Responsable:', permit.generalInfo?.responsable?.nombre || ''],\n    ],\n    theme: 'grid',\n    styles: { fontSize: 7, cellPadding: 1.5 },\n    columnStyles: { 0: { cellWidth: 35 }, 1: { cellWidth: 50 }, 2: { cellWidth: 35 }, 3: { cellWidth: 50 } }\n  });\n  yPos = (doc as any).lastAutoTable.finalY + 5;\n\n  // Alcance\n  checkPageBreak(20);\n  autoTable(doc, {\n    startY: yPos,\n    head: [['DESCRIPCI√ìN DEL TRABAJO (ALCANCE)']],\n    body: [[permit.generalInfo?.workDescription || 'No especificado']],\n    theme: 'grid',\n    styles: { fontSize: 7, cellPadding: 2 }\n  });\n  yPos = (doc as any).lastAutoTable.finalY + 5;\n\n  // ‚úÖ PELIGROS GENERALES\n  if (permit.verificacionPeligros) {\n    renderFieldsTable(PELIGROS_VERIFICACION, permit.verificacionPeligros, 'PELIGROS IDENTIFICADOS');\n  }\n\n  // ‚úÖ EPP (si existe)\n  if (permit.eppEmergencias?.epp) {\n    checkPageBreak(40);\n    drawHeader('EQUIPOS DE PROTECCI√ìN PERSONAL (EPP)');\n    \n    const eppRows = Object.entries(permit.eppEmergencias.epp).map(([key, value]) => [\n      key.replace(/([A-Z])/g, ' $1').trim(),\n      getStatusSymbol(value)\n    ]);\n\n    autoTable(doc, {\n      startY: yPos,\n      head: [['ELEMENTO EPP', 'REQUERIDO']],\n      body: eppRows,\n      theme: 'grid',\n      headStyles: { fillColor: [240, 240, 240], textColor: [0, 0, 0], fontSize: 7 },\n      bodyStyles: { fontSize: 6, cellPadding: 1 },\n      columnStyles: { 1: { halign: 'center', cellWidth: 25 } }\n    });\n    yPos = (doc as any).lastAutoTable.finalY + 5;\n  }\n\n  // ‚úÖ ANEXO 1: ALTURAS\n  if (permit.selectedWorkTypes?.alturas && permit.anexoAltura) {\n    renderFieldsTable(ANEXO_ALTURA_CAMPOS, permit.anexoAltura.aspectosSeguridad || {}, 'ANEXO 1 - TRABAJO EN ALTURAS');\n  }\n\n  // ‚úÖ ANEXO 2: ESPACIOS CONFINADOS\n  if (permit.selectedWorkTypes?.confinado && permit.anexoConfinado) {\n    renderFieldsTable(ANEXO_CONFINADO_CAMPOS, permit.anexoConfinado.identificacionPeligros || {}, 'ANEXO 2 - ESPACIOS CONFINADOS');\n    \n    // Tabla de pruebas de gases\n    if (permit.anexoConfinado.resultadosPruebasGases) {\n      checkPageBreak(30);\n      autoTable(doc, {\n        startY: yPos,\n        head: [['PAR√ÅMETRO', 'VALOR', 'CUMPLE']],\n        body: [\n          ['LEL (%)', permit.anexoConfinado.resultadosPruebasGases.lel || '‚Äî', permit.anexoConfinado.resultadosPruebasGases.lel === '0%' ? '‚úì' : '‚Äî'],\n          ['O2 (%)', permit.anexoConfinado.resultadosPruebasGases.o2 || '‚Äî', '‚Äî'],\n          ['H2S (PPM)', permit.anexoConfinado.resultadosPruebasGases.h2s || '‚Äî', '‚Äî'],\n          ['CO (PPM)', permit.anexoConfinado.resultadosPruebasGases.co || '‚Äî', '‚Äî'],\n        ],\n        theme: 'grid',\n        styles: { fontSize: 6, halign: 'center', cellPadding: 1 }\n      });\n      yPos = (doc as any).lastAutoTable.finalY + 5;\n    }\n  }\n\n  // ‚úÖ ANEXO 3: ENERG√çAS\n  if (permit.selectedWorkTypes?.energia && permit.anexoEnergias) {\n    renderFieldsTable(ANEXO_ENERGIA_CAMPOS, permit.anexoEnergias || {}, 'ANEXO 3 - CONTROL DE ENERG√çAS');\n  }\n\n  // ‚úÖ ANEXO 4: IZAJE\n  if (permit.selectedWorkTypes?.izaje && permit.anexoIzaje) {\n    renderFieldsTable(ANEXO_IZAJE_CAMPOS, permit.anexoIzaje.identificacionPeligros || {}, 'ANEXO 4 - IZAJE DE CARGAS');\n  }\n\n  // ‚úÖ ANEXO 5: EXCAVACIONES\n  if (permit.selectedWorkTypes?.excavacion && permit.anexoExcavaciones) {\n    renderFieldsTable(ANEXO_EXCAVACION_CAMPOS, permit.anexoExcavaciones.identificacionPeligros || {}, 'ANEXO 5 - EXCAVACIONES');\n  }\n\n  // Footer\n  const totalPages = (doc as any).internal.getNumberOfPages();\n  for (let i = 1; i <= totalPages; i++) {\n    doc.setPage(i);\n    doc.setFontSize(7);\n    doc.setTextColor(150);\n    doc.text(\n      `P√°gina ${i} de ${totalPages}`,\n      pageWidth / 2,\n      pageHeight - 8,\n      { align: 'center' }\n    );\n  }\n\n  doc.save(`Permiso_Italcol_${permit.number || permit.id.substring(0, 6)}.pdf`);\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1716, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/textarea.tsx"],"sourcesContent":["import * as React from 'react';\n\nimport {cn} from '@/lib/utils';\n\nconst Textarea = React.forwardRef<HTMLTextAreaElement, React.ComponentProps<'textarea'>>(\n  ({className, ...props}, ref) => {\n    return (\n      <textarea\n        className={cn(\n          'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    );\n  }\n);\nTextarea.displayName = 'Textarea';\n\nexport {Textarea};\n"],"names":[],"mappings":";;;;AAAA;AAEA;;;;AAEA,MAAM,yBAAW,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAC9B,CAAC,EAAC,SAAS,EAAE,GAAG,OAAM,EAAE;IACtB,qBACE,8OAAC;QACC,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,qTACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;AAEF,SAAS,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 1744, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/table.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className=\"relative w-full overflow-auto\">\n    <table\n      ref={ref}\n      className={cn(\"w-full caption-bottom text-sm\", className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = \"Table\"\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\n))\nTableHeader.displayName = \"TableHeader\"\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\n    {...props}\n  />\n))\nTableBody.displayName = \"TableBody\"\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = \"TableFooter\"\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = \"TableRow\"\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      \"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = \"TableHead\"\n\nconst TableCell = React.forwardRef<\n  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", className)}\n    {...props}\n  />\n))\nTableCell.displayName = \"TableCell\"\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nTableCaption.displayName = \"TableCaption\"\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,sBAAQ,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG3B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QAAI,WAAU;kBACb,cAAA,8OAAC;YACC,KAAK;YACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;YAC9C,GAAG,KAAK;;;;;;;;;;;AAIf,MAAM,WAAW,GAAG;AAEpB,MAAM,4BAAc,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QAAM,KAAK;QAAK,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,mBAAmB;QAAa,GAAG,KAAK;;;;;;AAEzE,YAAY,WAAW,GAAG;AAE1B,MAAM,0BAAY,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,4BAAc,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,2DACA;QAED,GAAG,KAAK;;;;;;AAGb,YAAY,WAAW,GAAG;AAE1B,MAAM,yBAAW,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG9B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,+EACA;QAED,GAAG,KAAK;;;;;;AAGb,SAAS,WAAW,GAAG;AAEvB,MAAM,0BAAY,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,oGACA;QAED,GAAG,KAAK;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,0BAAY,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,kDAAkD;QAC/D,GAAG,KAAK;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,6BAAe,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,sCAAsC;QACnD,GAAG,KAAK;;;;;;AAGb,aAAa,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 1854, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/permits/actions.ts"],"sourcesContent":["\n\n'use server';\n\nimport { adminDb, isAdminReady } from '@/lib/firebase-admin';\nimport { revalidatePath } from 'next/cache';\nimport type { Permit, ExternalWorker, PermitStatus, PermitClosure, Approval, UserRole, AnexoAltura, AnexoConfinado, AnexoEnergias, AnexoExcavaciones, AnexoIzaje, AnexoATS, PermitGeneralInfo, JustificacionATS, ValidacionDiaria, User, Notification } from '@/types';\nimport { FieldValue, UpdateData, Timestamp } from 'firebase-admin/firestore';\nimport { sendWhatsAppNotification } from '@/lib/notifications';\nimport { getEmailForUser, sendPermitUpdateEmail } from '@/lib/email';\nimport { config } from 'dotenv';\nconfig();\n\n// --- Funciones Auxiliares para Notificaciones ---\n\nconst getInvolvedUsers = async (permit: Permit): Promise<string[]> => {\n  const userIds = new Set<string>();\n\n  // 1. Creador del permiso\n  if (permit.createdBy) {\n    userIds.add(permit.createdBy);\n  }\n\n  // 2. Usuarios que han firmado\n  Object.values(permit.approvals || {}).forEach(approval => {\n    if (approval && approval.userId) {\n      userIds.add(approval.userId);\n    }\n  });\n\n  // 3. Roles administrativos o de supervisi√≥n que deber√≠an ser notificados\n  const adminsQuery = await adminDb.collection('users').where('role', 'in', ['admin', 'autorizante', 'lider_sst']).get();\n  adminsQuery.forEach(doc => userIds.add(doc.id));\n\n  return Array.from(userIds);\n};\n\nconst createNotification = async (\n  userId: string,\n  permit: Permit,\n  message: string,\n  type: Notification['type'],\n  triggeredBy: { uid: string, displayName: string | null }\n) => {\n  const notification: Omit<Notification, 'id'> = {\n    userId,\n    permitId: permit.id,\n    permitNumber: permit.number || '',\n    message,\n    type,\n    isRead: false,\n    createdAt: FieldValue.serverTimestamp() as Timestamp,\n    triggeredBy,\n  };\n  await adminDb.collection('notifications').add(notification as any);\n  \n  // Enviar correo electr√≥nico\n  const userEmail = await getEmailForUser(userId);\n  if (userEmail) {\n    await sendPermitUpdateEmail({\n      to: userEmail,\n      subject: `Actualizaci√≥n en Permiso SGTC: ${permit.number || permit.id}`,\n      html: `<p>${message}</p><p>Puedes ver los detalles del permiso haciendo clic <a href=\"${process.env.NEXT_PUBLIC_BASE_URL}/permits/${permit.id}\">aqu√≠</a>.</p>`\n    });\n  }\n};\n\n// --- Fin de Funciones de Notificaciones ---\n\nconst workTypesMap: {[key: string]: string} = {\n  'alturas': 'Trabajo en Alturas',\n  'confinado': 'Espacios Confinados',\n  'energia': 'Control de Energ√≠as',\n  'izaje': 'Izaje de Cargas',\n  'excavacion': 'Excavaciones',\n  'general': 'Trabajo General'\n};\n\nconst getWorkTypesString = (permit: Partial<Permit>): string => {\n  const selectedTypes: string[] = [];\n  if (permit.trabajoAlturas) selectedTypes.push('Trabajo en Alturas');\n  if (permit.espaciosConfinados) selectedTypes.push('Espacios Confinados');\n  if (permit.controlEnergia) selectedTypes.push('Control de Energ√≠as');\n  if (permit.izajeCargas) selectedTypes.push('Izaje de Cargas');\n  if (permit.excavaciones) selectedTypes.push('Excavaciones');\n  \n  if (selectedTypes.length === 0) {\n    if (permit.trabajoGeneral) return 'Trabajo General';\n    // Fallback for old data structure\n    if (permit.workType && Array.isArray(permit.workType)) {\n      return permit.workType.map(key => workTypesMap[key] || key).join(', ');\n    }\n    return 'Trabajo General';\n  }\n  return selectedTypes.join(', ');\n};\n\nconst getStatusText = (status: string) => {\n    const statusText: {[key: string]: string} = {\n      'borrador': 'Borrador',\n      'pendiente_revision': 'Pendiente de Revisi√≥n',\n      'aprobado': 'Aprobado',\n      'en_ejecucion': 'En Ejecuci√≥n',\n      'suspendido': 'Suspendido',\n      'cerrado': 'Cerrado',\n      'rechazado': 'Rechazado'\n    };\n    return statusText[status] || status;\n  };\n\nconst signatureRoles: { [key in 'solicitante' | 'autorizante' | 'mantenimiento' | 'lider_sst' | 'coordinador_alturas']: string } = {\n  coordinador_alturas: 'COORDINADOR DE TRABAJOS EN ALTURAS',\n  solicitante: 'QUIEN SOLICITA (L√çDER A CARGO DEL EQUIPO EJECUTANTE)',\n  autorizante: 'QUIEN AUTORIZA (JEFES Y DUE√ëOS DE AREA)',\n  mantenimiento: 'PERSONAL DE MANTENIMIENTO',\n  lider_sst: 'Firma SST',\n};\n\ntype PermitCreateData = Omit<Permit, 'id' | 'createdAt' | 'status' | 'createdBy' | 'number' | 'user' | 'approvals' | 'closure'> & {\n  userId: string;\n  userDisplayName: string | null;\n  userEmail: string | null;\n  userPhotoURL: string | null;\n};\n\nexport async function createPermit(data: PermitCreateData) {\n  if (!data.userId) {\n    return { success: false, error: 'User not authenticated' };\n  }\n   if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const { userId, userDisplayName, userEmail, userPhotoURL, ...permitData } = data;\n\n  const initialApprovals = {\n    solicitante: { status: 'pendiente' as const },\n    autorizante: { status: 'pendiente' as const },\n    mantenimiento: { status: 'pendiente' as const },\n    lider_sst: { status: 'pendiente' as const },\n    coordinador_alturas: { status: 'pendiente' as const },\n  };\n\n  const permitPayload: Omit<Permit, 'id'> = {\n    ...permitData,\n    status: 'pendiente_revision' as const,\n    createdBy: userId,\n    createdAt: FieldValue.serverTimestamp() as Timestamp,\n    user: {\n      displayName: userDisplayName,\n      email: userEmail,\n      photoURL: userPhotoURL,\n    },\n    approvals: initialApprovals,\n    trabajoAlturas: data.trabajoAlturas || false,\n    isSSTSignatureRequired: data.isSSTSignatureRequired || false,\n    closure: {},\n  };\n  \n  try {\n    const docRef = await adminDb.collection('permits').add(permitPayload as any);\n    const permitNumber = `PT-${Date.now()}-${docRef.id.substring(0, 6).toUpperCase()}`;\n    await docRef.update({ number: permitNumber });\n    \n    console.log('‚úÖ [Action] Permiso creado con √©xito en Firestore:', docRef.id);\n\n    const createdPermit = { ...permitPayload, id: docRef.id, number: permitNumber } as Permit;\n    const involvedUsers = await getInvolvedUsers(createdPermit);\n    const message = `Se cre√≥ un nuevo permiso de trabajo: #${permitNumber}`;\n    \n    for (const uid of involvedUsers) {\n      if (uid !== userId) {\n        await createNotification(uid, createdPermit, message, 'creation', { uid: userId, displayName: userDisplayName });\n      }\n    }\n\n    const workTypesText = getWorkTypesString(permitPayload);\n    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n    const permitUrl = `${baseUrl}/permits/${docRef.id}`;\n    \n    const messageBody = `*¬°Alerta de Seguridad SGPT!* üö®\nSe ha creado una nueva solicitud de permiso de trabajo.\n\nüìÑ *N√∫mero:* ${permitNumber}\nüë§ *Solicitante:* ${userDisplayName || 'N/A'}\nüõ†Ô∏è *Tipo de Trabajo:* ${workTypesText}\n\nPor favor, revise la solicitud para su aprobaci√≥n en el siguiente enlace:\n${permitUrl}`;\n    \n    await sendWhatsAppNotification(messageBody);\n    \n    revalidatePath('/permits');\n    revalidatePath('/dashboard');\n    \n    return { success: true, permitId: docRef.id, permitNumber };\n  } catch (error: any) {\n    console.error(\"‚ùå [Action] Error al crear permiso:\", error);\n    return { \n      success: false, \n      error: error.message || 'Could not create permit. Please try again.' \n    };\n  }\n}\n\nexport async function savePermitDraft(data: PermitCreateData & { draftId?: string }) {\n  if (!data.userId) {\n    return { success: false, error: 'User not authenticated' };\n  }\n  if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const { userId, userDisplayName, userEmail, userPhotoURL, draftId, ...permitData } = data;\n\n  const initialApprovals = {\n    solicitante: { status: 'pendiente' as const },\n    autorizante: { status: 'pendiente' as const },\n    mantenimiento: { status: 'pendiente' as const },\n    lider_sst: { status: 'pendiente' as const },\n    coordinador_alturas: { status: 'pendiente' as const },\n  };\n\n  const permitPayload: Omit<Permit, 'id' | 'createdAt'> = {\n    ...permitData,\n    status: 'borrador' as const,\n    createdBy: userId,\n    user: {\n      displayName: userDisplayName,\n      email: userEmail,\n      photoURL: userPhotoURL,\n    },\n    approvals: initialApprovals,\n    trabajoAlturas: data.trabajoAlturas || false,\n    isSSTSignatureRequired: data.isSSTSignatureRequired || false,\n  };\n\n  try {\n    if (draftId) {\n      // Actualizar un borrador existente\n      const docRef = adminDb.collection('permits').doc(draftId);\n      await docRef.update({ ...permitPayload, updatedAt: FieldValue.serverTimestamp() });\n      revalidatePath(`/permits/${draftId}`);\n      revalidatePath('/permits');\n      return { success: true, permitId: draftId, isUpdate: true };\n    } else {\n      // Crear un nuevo borrador\n      const payloadWithTimestamp = { ...permitPayload, createdAt: FieldValue.serverTimestamp() };\n      const docRef = await adminDb.collection('permits').add(payloadWithTimestamp as any);\n      revalidatePath('/permits');\n      return { success: true, permitId: docRef.id, isUpdate: false };\n    }\n  } catch (error: any) {\n    console.error(\"‚ùå [Action] Error al guardar borrador:\", error);\n    return { \n      success: false, \n      error: error.message || 'Could not save draft. Please try again.' \n    };\n  }\n}\n\nexport async function addSignatureAndNotify(\n  permitId: string, \n  role: 'solicitante' | 'autorizante' | 'mantenimiento' | 'lider_sst' | 'coordinador_alturas' | 'cierre_autoridad' | 'cierre_responsable' | 'cancelacion', \n  signatureType: 'firmaApertura' | 'firmaCierre',\n  signatureDataUrl: string,\n  user: { uid: string, displayName: string | null, role?: UserRole, empresa?: string },\n  comments?: string\n) {\n    if (!permitId || !role || !user || !user.uid || !user.role) {\n        return { success: false, error: 'Par√°metros inv√°lidos para guardar la firma.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n    }\n\n    try {\n        const docRef = adminDb.collection('permits').doc(permitId);\n        const permitDocBefore = await docRef.get();\n        if (!permitDocBefore.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n        const permitBeforeData = permitDocBefore.data() as Permit;\n\n        const updateData: UpdateData<Permit> = {};\n\n        // L√≥gica para manejar firmas de cierre y cancelaci√≥n\n        if (role.startsWith('cierre_') || role === 'cancelacion') {\n            const closureRole = role === 'cierre_autoridad' ? 'autoridad' : (role === 'cierre_responsable' ? 'responsable' : 'canceladoPor');\n            const closurePath = `closure.${closureRole}`;\n            \n            const existingClosureData = (permitBeforeData.closure as any)?.[closureRole] || {};\n\n            updateData[closurePath as keyof UpdateData<Permit>] = {\n                ...existingClosureData,\n                firma: signatureDataUrl,\n                nombre: user.displayName,\n                fecha: FieldValue.serverTimestamp() \n            };\n            \n            if (role === 'cancelacion') {\n                updateData['closure.razonCancelacion'] = comments || 'No especificado';\n                updateData['closure.cancelado'] = 'si';\n            }\n\n        } else {\n            // ‚úÖ VALIDACI√ìN DE PERMISOS ANTES DE FIRMAR\n            const canSign = await validateSignaturePermission(permitId, role, user);\n            if (!canSign.allowed) {\n                return { success: false, error: canSign.reason };\n            }\n\n            const approvalData: Partial<Approval> = {\n                status: 'aprobado',\n                firmaApertura: signatureDataUrl,\n                userName: user.displayName,\n                userId: user.uid,\n                signedAt: FieldValue.serverTimestamp() as any,\n                userRole: user.role,\n                userEmpresa: user.empresa || 'N/A',\n                comments: comments || '',\n            }\n            \n            updateData[`approvals.${role}`] = approvalData;\n            \n            // ‚úÖ L√ìGICA DE FIRMAS SEG√öN EL ROL\n            if (signatureType === 'firmaApertura') {\n                const validationPayload: ValidacionDiaria = { \n                    dia: 1, \n                    nombre: user.displayName || '', \n                    firma: signatureDataUrl, \n                    fecha: new Date().toISOString() \n                };\n                \n                // ‚úÖ SOLICITANTE FIRMA: Cambia de Borrador a Pendiente de Revisi√≥n\n                if (role === 'solicitante') {\n                    if (permitBeforeData.status === 'borrador') {\n                        const permitNumber = `PT-${Date.now()}-${permitId.substring(0, 6).toUpperCase()}`;\n                        updateData['number'] = permitNumber;\n                        updateData['status'] = 'pendiente_revision';\n                    }\n                    \n                    // Validaci√≥n diaria inicial del responsable\n                    ['anexoAltura', 'anexoConfinado', 'anexoIzaje', 'anexoExcavaciones'].forEach(anexo => {\n                        if ((permitBeforeData as any)?.[anexo]) {\n                            const currentValidations = (permitBeforeData as any)[anexo].validacion?.responsable || [];\n                            if (!currentValidations[0]?.firma) {\n                                currentValidations[0] = validationPayload;\n                                updateData[`${anexo}.validacion.responsable`] = currentValidations;\n                            }\n                        }\n                    });\n\n                // ‚úÖ AUTORIZANTE FIRMA: Agrega validaci√≥n diaria de autoridad\n                } else if (role === 'autorizante') {\n                    ['anexoAltura', 'anexoConfinado', 'anexoIzaje', 'anexoExcavaciones'].forEach(anexo => {\n                        if ((permitBeforeData as any)?.[anexo]) {\n                           const currentValidations = (permitBeforeData as any)[anexo].validacion?.autoridad || [];\n                            if (!currentValidations[0]?.firma) {\n                                currentValidations[0] = validationPayload;\n                                updateData[`${anexo}.validacion.autoridad`] = currentValidations;\n                            }\n                        }\n                    });\n                }\n            }\n\n            // ‚úÖ VERIFICACI√ìN AUTOM√ÅTICA: ¬øTodas las firmas requeridas est√°n completas?\n            const updatedPermitData = { \n                ...permitBeforeData, \n                approvals: { ...permitBeforeData.approvals, [role]: approvalData }\n            };\n            \n            if (await checkAllRequiredSignaturesComplete(updatedPermitData)) {\n                // üöÄ CAMBIO AUTOM√ÅTICO DE PENDIENTE_REVISION ‚Üí EN_EJECUCION\n                if (permitBeforeData.status === 'pendiente_revision') {\n                    updateData['status'] = 'en_ejecucion';\n                }\n            }\n        }\n        \n        await docRef.update(updateData);\n        \n        const permitDoc = await docRef.get();\n        const updatedPermitData = { id: permitDoc.id, ...permitDoc.data() } as Permit;\n        \n        const signatureRoleName = (signatureRoles as any)[role] || role.replace('_', ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n        \n        const message = `${user.displayName || 'Un usuario'} ha firmado el permiso #${updatedPermitData.number} como ${signatureRoleName}.`;\n        const involvedUsers = await getInvolvedUsers(updatedPermitData);\n        \n        for (const uid of involvedUsers) {\n          if (uid !== user.uid) {\n            await createNotification(uid, updatedPermitData, message, 'signature', user);\n          }\n        }\n        \n        // ‚úÖ NOTIFICACI√ìN ESPECIAL SI EL PERMISO PAS√ì AUTOM√ÅTICAMENTE A EN_EJECUCION\n        if (updateData['status'] === 'en_ejecucion') {\n            const executionMessage = `El permiso #${updatedPermitData.number} ha completado todas las aprobaciones requeridas y ahora est√° EN EJECUCI√ìN.`;\n            for (const uid of involvedUsers) {\n                 await createNotification(uid, updatedPermitData, executionMessage, 'approval', user);\n            }\n            \n            // Notificaci√≥n WhatsApp\n            const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n            const permitUrl = `${baseUrl}/permits/${permitId}`;\n            const whatsappMsg = `*¬°PERMISO EN EJECUCI√ìN!* ‚úÖ\n\nüìÑ *N√∫mero:* ${updatedPermitData.number}\nüìç *√Årea:* ${permitBeforeData.generalInfo?.areaEspecifica || 'N/A'}\nüõ†Ô∏è *Tipo:* ${getWorkTypesString(permitBeforeData)}\n\n‚úÖ Todas las firmas requeridas han sido completadas.\nEl permiso est√° ahora EN EJECUCI√ìN.\n\nVer detalles: ${permitUrl}`;\n            \n            await sendWhatsAppNotification(whatsappMsg);\n        }\n\n        revalidatePath(`/permits/${permitId}`);\n        return { success: true };\n\n    } catch (error: any) {\n        console.error(\"‚ùå Error al guardar firma y notificar:\", error);\n        return {\n            success: false,\n            error: error.message || 'No se pudo guardar la firma.'\n        };\n    }\n}\n\n// ‚úÖ FUNCI√ìN CORREGIDA: Verificar si todas las firmas requeridas est√°n completas\nasync function checkAllRequiredSignaturesComplete(\n  permitData: Permit\n): Promise<boolean> {\n    const { approvals } = permitData;\n    \n    // Firma del solicitante es SIEMPRE requerida\n    if (approvals?.solicitante?.status !== 'aprobado') {\n        return false;\n    }\n    \n    // Firma del autorizante es SIEMPRE requerida\n    if (approvals?.autorizante?.status !== 'aprobado') {\n        return false;\n    }\n    \n    // Si hay trabajos en alturas, requiere firma del coordinador\n    if (permitData.trabajoAlturas || permitData.selectedWorkTypes?.alturas) {\n        if (approvals?.coordinador_alturas?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    // Si hay control de energ√≠a, requiere firma de mantenimiento\n    if (permitData.controlEnergia) {\n        if (approvals?.mantenimiento?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    // Si SST es requerido, validar su firma\n    if (permitData.isSSTSignatureRequired) {\n        if (approvals?.lider_sst?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n// ‚úÖ FUNCI√ìN MEJORADA: Validaci√≥n de transiciones de estado\nfunction validateStateTransition(currentStatus: PermitStatus, targetStatus: PermitStatus, userRole: UserRole): { allowed: boolean, reason?: string } {\n    const allowedTransitions: Partial<Record<PermitStatus, Partial<Record<PermitStatus, UserRole[]>>>> = {\n        'borrador': {\n            'pendiente_revision': ['solicitante', 'lider_tarea', 'admin']\n        },\n        'pendiente_revision': {\n            'en_ejecucion': ['autorizante', 'admin'],\n            'rechazado': ['autorizante', 'lider_sst', 'admin']\n        },\n        'en_ejecucion': {\n            'suspendido': ['lider_sst', 'admin'],\n            'cerrado': ['lider_tarea', 'autorizante', 'admin']\n        },\n        'suspendido': {\n            'en_ejecucion': ['lider_sst', 'admin'],\n            'cerrado': ['lider_tarea', 'autorizante', 'admin']\n        },\n        // Mantener compatibilidad con permisos antiguos que tengan estado \"aprobado\"\n        'aprobado': {\n            'en_ejecucion': ['lider_tarea', 'admin'],\n            'rechazado': ['autorizante', 'lider_sst', 'admin']\n        }\n    };\n    \n    const allowedRoles = allowedTransitions[currentStatus]?.[targetStatus];\n    if (!allowedRoles) {\n        return { allowed: false, reason: `Transici√≥n de '${currentStatus}' a '${targetStatus}' no est√° permitida.` };\n    }\n\n    if (!allowedRoles.includes(userRole) && userRole !== 'admin') {\n        return { allowed: false, reason: `Tu rol (${userRole}) no tiene permisos para cambiar el estado a '${targetStatus}'.` };\n    }\n\n    return { allowed: true };\n}\n\nexport async function updatePermitStatus(\n  permitId: string,\n  status: PermitStatus,\n  currentUser: { uid: string, displayName: string | null, role?: UserRole },\n  reason?: string\n) {\n    if (!permitId || !currentUser.uid || !currentUser.role) {\n        return { success: false, error: 'Par√°metros inv√°lidos o usuario sin rol.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas.' };\n    }\n\n    try {\n        const docRef = adminDb.collection('permits').doc(permitId);\n        const permitSnap = await docRef.get();\n        if (!permitSnap.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n        const permitData = permitSnap.data() as Permit;\n        \n        // ‚úÖ Validar transici√≥n de estado\n        const transition = validateStateTransition(permitData.status, status, currentUser.role);\n        if (!transition.allowed) {\n            return { success: false, error: transition.reason };\n        }\n\n        const updateData: UpdateData<Permit> = { status };\n\n        // ‚úÖ Guardar raz√≥n de rechazo\n        if (status === 'rechazado' && reason) {\n            updateData.rejectionReason = reason;\n        }\n        \n        // ‚úÖ Marcar fecha de cierre\n        if (status === 'cerrado') {\n            updateData['closure.fechaCierre'] = FieldValue.serverTimestamp();\n            updateData['closure.terminado'] = 'si';\n        }\n\n        await docRef.update(updateData);\n        \n        const updatedPermitData = { ...permitData, ...updateData, id: permitId } as Permit;\n        const triggeredBy = currentUser;\n        \n        let notificationType: Notification['type'] = 'status_change';\n        let message = `${currentUser.displayName || 'Un usuario'} ha cambiado el estado del permiso #${permitData.number} a: ${getStatusText(status)}.`;\n\n        if (status === 'en_ejecucion') {\n            notificationType = 'approval';\n            message = `El permiso #${permitData.number} ha sido puesto EN EJECUCI√ìN manualmente.`;\n        } else if (status === 'rechazado') {\n            notificationType = 'rejection';\n            message = `${currentUser.displayName || 'Un usuario'} ha rechazado el permiso #${permitData.number}.`;\n            if (reason) message += ` Motivo: ${reason}`;\n        } else if (status === 'cerrado') {\n            notificationType = 'cancellation';\n            message = `${currentUser.displayName || 'Un usuario'} ha cerrado el permiso #${permitData.number}.`;\n        }\n        \n        const involvedUsers = await getInvolvedUsers(updatedPermitData);\n        for (const uid of involvedUsers) {\n             if (uid !== currentUser.uid) {\n                await createNotification(uid, updatedPermitData, message, notificationType, triggeredBy);\n            }\n        }\n\n        const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n        const permitUrl = `${baseUrl}/permits/${permitId}`;\n\n        let messageBody = `*Actualizaci√≥n de Estado - SGTC* üîÑ\nEl estado del permiso *${permitData.number || permitId}* ha cambiado.\n\n*Nuevo Estado:* ${getStatusText(status)}\n\nPuede ver los detalles aqu√≠:\n${permitUrl}`;\n\n        if (status === 'rechazado' && reason) {\n          messageBody += `\\n\\n*Motivo del rechazo:* ${reason}`;\n        }\n        \n        await sendWhatsAppNotification(messageBody);\n        \n        revalidatePath(`/permits/${permitId}`);\n        revalidatePath('/permits');\n        revalidatePath('/dashboard');\n\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"‚ùå Error updating permit status:\", error);\n        return {\n            success: false,\n            error: error.message || 'Could not update permit status.'\n        };\n    }\n}\n\n// ‚úÖ FUNCI√ìN MEJORADA: Validaci√≥n de permisos de firma con orden jer√°rquico\nasync function validateSignaturePermission(\n    permitId: string, \n    signatureRole: string, \n    currentUser: { uid: string, role?: UserRole }\n): Promise<{ allowed: boolean, reason?: string }> {\n    const docRef = adminDb.collection('permits').doc(permitId);\n    const permitDoc = await docRef.get();\n    if (!permitDoc.exists) {\n        return { allowed: false, reason: 'Permiso no encontrado.' };\n    }\n    const permit = permitDoc.data() as Permit;\n    \n    // ‚úÖ Verificar que el permiso est√© en un estado v√°lido para firmar\n    if (!['borrador', 'pendiente_revision'].includes(permit.status)) {\n        return { allowed: false, reason: `No se puede firmar un permiso en estado '${permit.status}'.` };\n    }\n    \n    switch (signatureRole) {\n        case 'coordinador_alturas':\n            // Debe haber trabajo en alturas\n            if (!permit.trabajoAlturas && !permit.selectedWorkTypes?.alturas) {\n                return { allowed: false, reason: 'Esta firma solo aplica para trabajos en alturas.' };\n            }\n            // Solo el creador o admin puede gestionar esta firma\n            if (permit.createdBy !== currentUser.uid && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Solo el creador del permiso puede gestionar esta firma.' };\n            }\n            break;\n            \n        case 'solicitante':\n            if (permit.createdBy !== currentUser.uid && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Solo el creador del permiso puede firmar como solicitante.' };\n            }\n            // ‚úÖ Si hay anexo de alturas, verificar firma del coordinador primero\n            if ((permit.trabajoAlturas || permit.selectedWorkTypes?.alturas) && \n                permit.approvals?.coordinador_alturas?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del Coordinador de Trabajos en Alturas.' };\n            }\n            break;\n            \n        case 'autorizante':\n            if (currentUser.role !== 'autorizante' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de autorizante requerido para esta firma.' };\n            }\n            if (permit.approvals?.solicitante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del solicitante.' };\n            }\n            break;\n            \n        case 'lider_sst':\n            if (currentUser.role !== 'lider_sst' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de L√≠der SST requerido para esta firma.' };\n            }\n            // ‚úÖ Solo requerido si isSSTSignatureRequired es true\n            if (!permit.isSSTSignatureRequired) {\n                return { allowed: false, reason: 'Firma de SST no es requerida para este permiso.' };\n            }\n            if (permit.approvals?.solicitante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del solicitante.' };\n            }\n            break;\n            \n        case 'mantenimiento':\n             if (currentUser.role !== 'mantenimiento' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de Mantenimiento requerido para esta firma.' };\n            }\n            if (!permit.controlEnergia) {\n                return { allowed: false, reason: 'Firma de Mantenimiento solo aplica cuando hay control de energ√≠as.' };\n            }\n            if (permit.approvals?.autorizante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del autorizante.' };\n            }\n            break;\n    }\n    \n    return { allowed: true };\n}\n\nexport async function addDailyValidationSignature(\n  permitId: string, \n  anexoName: string, \n  validationType: 'autoridad' | 'responsable', \n  index: number, \n  data: ValidacionDiaria, \n  user: User\n) {\n  if (!permitId || !anexoName || !validationType || index < 0 || !data || !user) {\n    return { success: false, error: 'Par√°metros inv√°lidos.' };\n  }\n\n  if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const docRef = adminDb.collection('permits').doc(permitId);\n  try {\n    const permitSnap = await docRef.get();\n    if (!permitSnap.exists) {\n      return { success: false, error: 'El permiso no existe.' };\n    }\n    const permitData = permitSnap.data() as Permit;\n\n    // ‚úÖ Verificar que el permiso est√© en ejecuci√≥n para validaciones diarias\n    if (!['en_ejecucion', 'suspendido'].includes(permitData.status)) {\n        return { success: false, error: 'Solo se pueden agregar validaciones diarias en permisos EN EJECUCI√ìN o SUSPENDIDOS.' };\n    }\n\n    const anexoData = (permitData as any)[anexoName];\n    if (!anexoData) {\n      return { success: false, error: `El anexo ${anexoName} no existe en el permiso.` };\n    }\n    \n    const anexoUpdate: any = { ...anexoData };\n    if (!anexoUpdate.validacion) {\n        anexoUpdate.validacion = { autoridad: [], responsable: [] };\n    }\n\n    const validationArray = (anexoUpdate.validacion[validationType] as ValidacionDiaria[]) || [];\n    \n    while (validationArray.length <= index) {\n        validationArray.push({ dia: validationArray.length + 1, nombre: '', fecha: '', firma: '' });\n    }\n\n    validationArray[index] = data;\n    \n    const updatePath = `${anexoName}.validacion.${validationType}`;\n    \n    await docRef.update({\n      [updatePath]: validationArray,\n    });\n\n    const fullPermitData = { id: docRef.id, ...permitData } as Permit;\n    const anexoDisplayName = anexoName.replace('anexo', 'Anexo ');\n    const validationRoleName = validationType === 'autoridad' ? 'Autoridad del √Årea' : 'Responsable del Trabajo';\n    const day = index + 1;\n\n    const message = `${user.displayName || 'Un usuario'} ha realizado la validaci√≥n diaria (${validationRoleName}) para el D√çA ${day} del ${anexoDisplayName} en el permiso #${fullPermitData.number}.`;\n    const involvedUsers = await getInvolvedUsers(fullPermitData);\n    for (const uid of involvedUsers) {\n      if (uid !== user.uid) {\n        await createNotification(uid, fullPermitData, message, 'status_change', { uid: user.uid, displayName: user.displayName || null });\n      }\n    }\n\n    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n    const permitUrl = `${baseUrl}/permits/${permitId}`;\n    const whatsappMessage = `*Validaci√≥n Diaria - SGTC* ‚úçÔ∏è\nSe ha registrado una nueva firma de validaci√≥n diaria.\n\nüìÑ *Permiso:* ${fullPermitData.number || 'N/A'}\nüóìÔ∏è *D√≠a:* ${day}\nüë§ *Firmante:* ${user.displayName || 'N/A'}\n‚úÖ *Rol:* ${validationRoleName}\nüìã *Anexo:* ${anexoDisplayName}\n\nPuede ver los detalles aqu√≠:\n${permitUrl}`;\n    \n    await sendWhatsAppNotification(whatsappMessage);\n\n    revalidatePath(`/permits/${permitId}`);\n    return { success: true };\n\n  } catch (error: any) {\n    console.error(\"‚ùå Error al guardar la validaci√≥n diaria:\", error);\n    return { success: false, error: 'No se pudo guardar la firma de validaci√≥n.' };\n  }\n}\n\nexport async function addWorkerSignature(permitId: string, workerIndex: number, signatureType: 'firmaApertura' | 'firmaCierre', signatureDataUrl: string) {\n    if (!permitId || workerIndex < 0 || !signatureType || !signatureDataUrl) {\n        return { success: false, error: 'Faltan par√°metros.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n    }\n\n    const docRef = adminDb.collection('permits').doc(permitId);\n    try {\n        const permitSnap = await docRef.get();\n        if (!permitSnap.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n\n        const permitData = permitSnap.data() as Permit;\n        \n        // ‚úÖ CORRECCI√ìN: Validaci√≥n de estado corregida para firma de apertura\n        if (signatureType === 'firmaApertura' && !['pendiente_revision', 'aprobado', 'en_ejecucion'].includes(permitData.status)) {\n            return { success: false, error: 'Solo se puede firmar apertura cuando el permiso est√° pendiente, aprobado o en ejecuci√≥n.' };\n        }\n        if (signatureType === 'firmaCierre' && !['en_ejecucion', 'suspendido'].includes(permitData.status)) {\n            return { success: false, error: 'Solo se puede firmar cierre en permisos EN EJECUCI√ìN o SUSPENDIDOS.' };\n        }\n        \n        const workers = permitData.workers ? [...permitData.workers] : [];\n\n        if (workerIndex >= workers.length) {\n            return { success: false, error: '√çndice de trabajador inv√°lido.' };\n        }\n\n        const signatureField = signatureType === 'firmaApertura' ? 'firmaApertura' : 'firmaCierre';\n        const dateField = signatureType === 'firmaApertura' ? 'fechaFirmaApertura' : 'fechaFirmaCierre';\n\n        workers[workerIndex] = {\n            ...workers[workerIndex],\n            [signatureField]: signatureDataUrl,\n            [dateField]: new Date().toISOString(), \n        };\n\n        await docRef.update({ workers: workers });\n\n        revalidatePath(`/permits/${permitId}`);\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"Error al guardar la firma del trabajador:\", error);\n        return { success: false, error: 'No se pudo guardar la firma.' };\n    }\n}\n"],"names":[],"mappings":";;;;;;IA0wBsB,qBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 1867, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/permits/%5Bid%5D/components/WorkerSignatures.tsx"],"sourcesContent":["'use client';\nimport { useState } from 'react';\nimport type { Permit, ExternalWorker } from '@/types';\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\nimport { SignaturePad } from '@/components/ui/signature-pad';\nimport { useUser } from '@/hooks/use-user';\nimport { useToast } from '@/hooks/use-toast';\nimport { addWorkerSignature } from '../../actions';\nimport Image from 'next/image';\nimport { Signature, UserCheck, Lock } from 'lucide-react';\nimport { format } from 'date-fns';\n\ninterface WorkerSignaturesProps {\n  permit: Permit;\n}\n\nexport function WorkerSignatures({ permit }: WorkerSignaturesProps) {\n  const { user } = useUser();\n  const { toast } = useToast();\n  const [isSigning, setIsSigning] = useState(false);\n  const [signingInfo, setSigningInfo] = useState<{ type: 'firmaApertura' | 'firmaCierre'; index: number } | null>(null);\n\n  const handleOpenSignatureModal = (type: 'firmaApertura' | 'firmaCierre', index: number) => {\n    setSigningInfo({ type, index });\n    setIsSigning(true);\n  };\n  \n  const handleSaveSignature = async (signatureDataUrl: string) => {\n    if (!signingInfo || !user) return;\n\n    const { type, index } = signingInfo;\n    \n    const result = await addWorkerSignature(permit.id, index, type, signatureDataUrl);\n    \n    if (result.success) {\n      toast({ title: 'Firma de Trabajador Guardada' });\n    } else {\n      toast({ variant: 'destructive', title: 'Error', description: result.error });\n    }\n    \n    setIsSigning(false);\n    setSigningInfo(null);\n  };\n\n  const workers = permit.workers || [];\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2\"><UserCheck /> Firmas del Personal Ejecutante</CardTitle>\n      </CardHeader>\n      <CardContent>\n        <div className=\"overflow-x-auto\">\n            <Table>\n                <TableHeader>\n                    <TableRow>\n                    <TableHead>Nombre</TableHead>\n                    <TableHead>C√©dula</TableHead>\n                    <TableHead>Firma Apertura</TableHead>\n                    <TableHead>Firma Cierre</TableHead>\n                    </TableRow>\n                </TableHeader>\n                <TableBody>\n                    {workers.length > 0 ? workers.map((worker, index) => (\n                    <TableRow key={index}>\n                        <TableCell>{worker.nombre}</TableCell>\n                        <TableCell>{worker.cedula}</TableCell>\n                        <TableCell>\n                        {worker.firmaApertura ? (\n                             <div className=\"flex items-center gap-2\">\n                                <Image src={worker.firmaApertura} alt=\"Firma\" width={80} height={40} className=\"bg-white border rounded\" />\n                             </div>\n                        ) : (\n                            permit.status === 'pendiente_revision' || permit.status === 'aprobado' || permit.status === 'en_ejecucion' ? (\n                               <Button size=\"sm\" variant=\"outline\" onClick={() => handleOpenSignatureModal('firmaApertura', index)}>\n                                <Signature className=\"mr-2 h-4 w-4\"/> Firmar Apertura\n                               </Button>\n                            ) : null\n                        )}\n                        </TableCell>\n                         <TableCell>\n                        {worker.firmaCierre ? (\n                             <div className=\"flex items-center gap-2\">\n                                <Image src={worker.firmaCierre} alt=\"Firma\" width={80} height={40} className=\"bg-white border rounded\" />\n                             </div>\n                        ) : (\n                             permit.status === 'en_ejecucion' || permit.status === 'suspendido' ? (\n                               <Button size=\"sm\" variant=\"outline\" onClick={() => handleOpenSignatureModal('firmaCierre', index)}>\n                                <Lock className=\"mr-2 h-4 w-4\"/> Firmar Cierre\n                               </Button>\n                             ) : null\n                        )}\n                        </TableCell>\n                    </TableRow>\n                    )) : (\n                        <TableRow>\n                            <TableCell colSpan={4} className=\"h-24 text-center\">\n                                No se registraron trabajadores para este permiso.\n                            </TableCell>\n                        </TableRow>\n                    )}\n                </TableBody>\n            </Table>\n        </div>\n      </CardContent>\n      <Dialog open={isSigning} onOpenChange={setIsSigning}>\n          <DialogContent>\n              <DialogHeader><DialogTitle>Realizar Firma de Trabajador</DialogTitle></DialogHeader>\n              <SignaturePad onSave={handleSaveSignature} />\n          </DialogContent>\n      </Dialog>\n    </Card>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2189, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/permits/actions.ts"],"sourcesContent":["\n\n'use server';\n\nimport { adminDb, isAdminReady } from '@/lib/firebase-admin';\nimport { revalidatePath } from 'next/cache';\nimport type { Permit, ExternalWorker, PermitStatus, PermitClosure, Approval, UserRole, AnexoAltura, AnexoConfinado, AnexoEnergias, AnexoExcavaciones, AnexoIzaje, AnexoATS, PermitGeneralInfo, JustificacionATS, ValidacionDiaria, User, Notification } from '@/types';\nimport { FieldValue, UpdateData, Timestamp } from 'firebase-admin/firestore';\nimport { sendWhatsAppNotification } from '@/lib/notifications';\nimport { getEmailForUser, sendPermitUpdateEmail } from '@/lib/email';\nimport { config } from 'dotenv';\nconfig();\n\n// --- Funciones Auxiliares para Notificaciones ---\n\nconst getInvolvedUsers = async (permit: Permit): Promise<string[]> => {\n  const userIds = new Set<string>();\n\n  // 1. Creador del permiso\n  if (permit.createdBy) {\n    userIds.add(permit.createdBy);\n  }\n\n  // 2. Usuarios que han firmado\n  Object.values(permit.approvals || {}).forEach(approval => {\n    if (approval && approval.userId) {\n      userIds.add(approval.userId);\n    }\n  });\n\n  // 3. Roles administrativos o de supervisi√≥n que deber√≠an ser notificados\n  const adminsQuery = await adminDb.collection('users').where('role', 'in', ['admin', 'autorizante', 'lider_sst']).get();\n  adminsQuery.forEach(doc => userIds.add(doc.id));\n\n  return Array.from(userIds);\n};\n\nconst createNotification = async (\n  userId: string,\n  permit: Permit,\n  message: string,\n  type: Notification['type'],\n  triggeredBy: { uid: string, displayName: string | null }\n) => {\n  const notification: Omit<Notification, 'id'> = {\n    userId,\n    permitId: permit.id,\n    permitNumber: permit.number || '',\n    message,\n    type,\n    isRead: false,\n    createdAt: FieldValue.serverTimestamp() as Timestamp,\n    triggeredBy,\n  };\n  await adminDb.collection('notifications').add(notification as any);\n  \n  // Enviar correo electr√≥nico\n  const userEmail = await getEmailForUser(userId);\n  if (userEmail) {\n    await sendPermitUpdateEmail({\n      to: userEmail,\n      subject: `Actualizaci√≥n en Permiso SGTC: ${permit.number || permit.id}`,\n      html: `<p>${message}</p><p>Puedes ver los detalles del permiso haciendo clic <a href=\"${process.env.NEXT_PUBLIC_BASE_URL}/permits/${permit.id}\">aqu√≠</a>.</p>`\n    });\n  }\n};\n\n// --- Fin de Funciones de Notificaciones ---\n\nconst workTypesMap: {[key: string]: string} = {\n  'alturas': 'Trabajo en Alturas',\n  'confinado': 'Espacios Confinados',\n  'energia': 'Control de Energ√≠as',\n  'izaje': 'Izaje de Cargas',\n  'excavacion': 'Excavaciones',\n  'general': 'Trabajo General'\n};\n\nconst getWorkTypesString = (permit: Partial<Permit>): string => {\n  const selectedTypes: string[] = [];\n  if (permit.trabajoAlturas) selectedTypes.push('Trabajo en Alturas');\n  if (permit.espaciosConfinados) selectedTypes.push('Espacios Confinados');\n  if (permit.controlEnergia) selectedTypes.push('Control de Energ√≠as');\n  if (permit.izajeCargas) selectedTypes.push('Izaje de Cargas');\n  if (permit.excavaciones) selectedTypes.push('Excavaciones');\n  \n  if (selectedTypes.length === 0) {\n    if (permit.trabajoGeneral) return 'Trabajo General';\n    // Fallback for old data structure\n    if (permit.workType && Array.isArray(permit.workType)) {\n      return permit.workType.map(key => workTypesMap[key] || key).join(', ');\n    }\n    return 'Trabajo General';\n  }\n  return selectedTypes.join(', ');\n};\n\nconst getStatusText = (status: string) => {\n    const statusText: {[key: string]: string} = {\n      'borrador': 'Borrador',\n      'pendiente_revision': 'Pendiente de Revisi√≥n',\n      'aprobado': 'Aprobado',\n      'en_ejecucion': 'En Ejecuci√≥n',\n      'suspendido': 'Suspendido',\n      'cerrado': 'Cerrado',\n      'rechazado': 'Rechazado'\n    };\n    return statusText[status] || status;\n  };\n\nconst signatureRoles: { [key in 'solicitante' | 'autorizante' | 'mantenimiento' | 'lider_sst' | 'coordinador_alturas']: string } = {\n  coordinador_alturas: 'COORDINADOR DE TRABAJOS EN ALTURAS',\n  solicitante: 'QUIEN SOLICITA (L√çDER A CARGO DEL EQUIPO EJECUTANTE)',\n  autorizante: 'QUIEN AUTORIZA (JEFES Y DUE√ëOS DE AREA)',\n  mantenimiento: 'PERSONAL DE MANTENIMIENTO',\n  lider_sst: 'Firma SST',\n};\n\ntype PermitCreateData = Omit<Permit, 'id' | 'createdAt' | 'status' | 'createdBy' | 'number' | 'user' | 'approvals' | 'closure'> & {\n  userId: string;\n  userDisplayName: string | null;\n  userEmail: string | null;\n  userPhotoURL: string | null;\n};\n\nexport async function createPermit(data: PermitCreateData) {\n  if (!data.userId) {\n    return { success: false, error: 'User not authenticated' };\n  }\n   if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const { userId, userDisplayName, userEmail, userPhotoURL, ...permitData } = data;\n\n  const initialApprovals = {\n    solicitante: { status: 'pendiente' as const },\n    autorizante: { status: 'pendiente' as const },\n    mantenimiento: { status: 'pendiente' as const },\n    lider_sst: { status: 'pendiente' as const },\n    coordinador_alturas: { status: 'pendiente' as const },\n  };\n\n  const permitPayload: Omit<Permit, 'id'> = {\n    ...permitData,\n    status: 'pendiente_revision' as const,\n    createdBy: userId,\n    createdAt: FieldValue.serverTimestamp() as Timestamp,\n    user: {\n      displayName: userDisplayName,\n      email: userEmail,\n      photoURL: userPhotoURL,\n    },\n    approvals: initialApprovals,\n    trabajoAlturas: data.trabajoAlturas || false,\n    isSSTSignatureRequired: data.isSSTSignatureRequired || false,\n    closure: {},\n  };\n  \n  try {\n    const docRef = await adminDb.collection('permits').add(permitPayload as any);\n    const permitNumber = `PT-${Date.now()}-${docRef.id.substring(0, 6).toUpperCase()}`;\n    await docRef.update({ number: permitNumber });\n    \n    console.log('‚úÖ [Action] Permiso creado con √©xito en Firestore:', docRef.id);\n\n    const createdPermit = { ...permitPayload, id: docRef.id, number: permitNumber } as Permit;\n    const involvedUsers = await getInvolvedUsers(createdPermit);\n    const message = `Se cre√≥ un nuevo permiso de trabajo: #${permitNumber}`;\n    \n    for (const uid of involvedUsers) {\n      if (uid !== userId) {\n        await createNotification(uid, createdPermit, message, 'creation', { uid: userId, displayName: userDisplayName });\n      }\n    }\n\n    const workTypesText = getWorkTypesString(permitPayload);\n    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n    const permitUrl = `${baseUrl}/permits/${docRef.id}`;\n    \n    const messageBody = `*¬°Alerta de Seguridad SGPT!* üö®\nSe ha creado una nueva solicitud de permiso de trabajo.\n\nüìÑ *N√∫mero:* ${permitNumber}\nüë§ *Solicitante:* ${userDisplayName || 'N/A'}\nüõ†Ô∏è *Tipo de Trabajo:* ${workTypesText}\n\nPor favor, revise la solicitud para su aprobaci√≥n en el siguiente enlace:\n${permitUrl}`;\n    \n    await sendWhatsAppNotification(messageBody);\n    \n    revalidatePath('/permits');\n    revalidatePath('/dashboard');\n    \n    return { success: true, permitId: docRef.id, permitNumber };\n  } catch (error: any) {\n    console.error(\"‚ùå [Action] Error al crear permiso:\", error);\n    return { \n      success: false, \n      error: error.message || 'Could not create permit. Please try again.' \n    };\n  }\n}\n\nexport async function savePermitDraft(data: PermitCreateData & { draftId?: string }) {\n  if (!data.userId) {\n    return { success: false, error: 'User not authenticated' };\n  }\n  if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const { userId, userDisplayName, userEmail, userPhotoURL, draftId, ...permitData } = data;\n\n  const initialApprovals = {\n    solicitante: { status: 'pendiente' as const },\n    autorizante: { status: 'pendiente' as const },\n    mantenimiento: { status: 'pendiente' as const },\n    lider_sst: { status: 'pendiente' as const },\n    coordinador_alturas: { status: 'pendiente' as const },\n  };\n\n  const permitPayload: Omit<Permit, 'id' | 'createdAt'> = {\n    ...permitData,\n    status: 'borrador' as const,\n    createdBy: userId,\n    user: {\n      displayName: userDisplayName,\n      email: userEmail,\n      photoURL: userPhotoURL,\n    },\n    approvals: initialApprovals,\n    trabajoAlturas: data.trabajoAlturas || false,\n    isSSTSignatureRequired: data.isSSTSignatureRequired || false,\n  };\n\n  try {\n    if (draftId) {\n      // Actualizar un borrador existente\n      const docRef = adminDb.collection('permits').doc(draftId);\n      await docRef.update({ ...permitPayload, updatedAt: FieldValue.serverTimestamp() });\n      revalidatePath(`/permits/${draftId}`);\n      revalidatePath('/permits');\n      return { success: true, permitId: draftId, isUpdate: true };\n    } else {\n      // Crear un nuevo borrador\n      const payloadWithTimestamp = { ...permitPayload, createdAt: FieldValue.serverTimestamp() };\n      const docRef = await adminDb.collection('permits').add(payloadWithTimestamp as any);\n      revalidatePath('/permits');\n      return { success: true, permitId: docRef.id, isUpdate: false };\n    }\n  } catch (error: any) {\n    console.error(\"‚ùå [Action] Error al guardar borrador:\", error);\n    return { \n      success: false, \n      error: error.message || 'Could not save draft. Please try again.' \n    };\n  }\n}\n\nexport async function addSignatureAndNotify(\n  permitId: string, \n  role: 'solicitante' | 'autorizante' | 'mantenimiento' | 'lider_sst' | 'coordinador_alturas' | 'cierre_autoridad' | 'cierre_responsable' | 'cancelacion', \n  signatureType: 'firmaApertura' | 'firmaCierre',\n  signatureDataUrl: string,\n  user: { uid: string, displayName: string | null, role?: UserRole, empresa?: string },\n  comments?: string\n) {\n    if (!permitId || !role || !user || !user.uid || !user.role) {\n        return { success: false, error: 'Par√°metros inv√°lidos para guardar la firma.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n    }\n\n    try {\n        const docRef = adminDb.collection('permits').doc(permitId);\n        const permitDocBefore = await docRef.get();\n        if (!permitDocBefore.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n        const permitBeforeData = permitDocBefore.data() as Permit;\n\n        const updateData: UpdateData<Permit> = {};\n\n        // L√≥gica para manejar firmas de cierre y cancelaci√≥n\n        if (role.startsWith('cierre_') || role === 'cancelacion') {\n            const closureRole = role === 'cierre_autoridad' ? 'autoridad' : (role === 'cierre_responsable' ? 'responsable' : 'canceladoPor');\n            const closurePath = `closure.${closureRole}`;\n            \n            const existingClosureData = (permitBeforeData.closure as any)?.[closureRole] || {};\n\n            updateData[closurePath as keyof UpdateData<Permit>] = {\n                ...existingClosureData,\n                firma: signatureDataUrl,\n                nombre: user.displayName,\n                fecha: FieldValue.serverTimestamp() \n            };\n            \n            if (role === 'cancelacion') {\n                updateData['closure.razonCancelacion'] = comments || 'No especificado';\n                updateData['closure.cancelado'] = 'si';\n            }\n\n        } else {\n            // ‚úÖ VALIDACI√ìN DE PERMISOS ANTES DE FIRMAR\n            const canSign = await validateSignaturePermission(permitId, role, user);\n            if (!canSign.allowed) {\n                return { success: false, error: canSign.reason };\n            }\n\n            const approvalData: Partial<Approval> = {\n                status: 'aprobado',\n                firmaApertura: signatureDataUrl,\n                userName: user.displayName,\n                userId: user.uid,\n                signedAt: FieldValue.serverTimestamp() as any,\n                userRole: user.role,\n                userEmpresa: user.empresa || 'N/A',\n                comments: comments || '',\n            }\n            \n            updateData[`approvals.${role}`] = approvalData;\n            \n            // ‚úÖ L√ìGICA DE FIRMAS SEG√öN EL ROL\n            if (signatureType === 'firmaApertura') {\n                const validationPayload: ValidacionDiaria = { \n                    dia: 1, \n                    nombre: user.displayName || '', \n                    firma: signatureDataUrl, \n                    fecha: new Date().toISOString() \n                };\n                \n                // ‚úÖ SOLICITANTE FIRMA: Cambia de Borrador a Pendiente de Revisi√≥n\n                if (role === 'solicitante') {\n                    if (permitBeforeData.status === 'borrador') {\n                        const permitNumber = `PT-${Date.now()}-${permitId.substring(0, 6).toUpperCase()}`;\n                        updateData['number'] = permitNumber;\n                        updateData['status'] = 'pendiente_revision';\n                    }\n                    \n                    // Validaci√≥n diaria inicial del responsable\n                    ['anexoAltura', 'anexoConfinado', 'anexoIzaje', 'anexoExcavaciones'].forEach(anexo => {\n                        if ((permitBeforeData as any)?.[anexo]) {\n                            const currentValidations = (permitBeforeData as any)[anexo].validacion?.responsable || [];\n                            if (!currentValidations[0]?.firma) {\n                                currentValidations[0] = validationPayload;\n                                updateData[`${anexo}.validacion.responsable`] = currentValidations;\n                            }\n                        }\n                    });\n\n                // ‚úÖ AUTORIZANTE FIRMA: Agrega validaci√≥n diaria de autoridad\n                } else if (role === 'autorizante') {\n                    ['anexoAltura', 'anexoConfinado', 'anexoIzaje', 'anexoExcavaciones'].forEach(anexo => {\n                        if ((permitBeforeData as any)?.[anexo]) {\n                           const currentValidations = (permitBeforeData as any)[anexo].validacion?.autoridad || [];\n                            if (!currentValidations[0]?.firma) {\n                                currentValidations[0] = validationPayload;\n                                updateData[`${anexo}.validacion.autoridad`] = currentValidations;\n                            }\n                        }\n                    });\n                }\n            }\n\n            // ‚úÖ VERIFICACI√ìN AUTOM√ÅTICA: ¬øTodas las firmas requeridas est√°n completas?\n            const updatedPermitData = { \n                ...permitBeforeData, \n                approvals: { ...permitBeforeData.approvals, [role]: approvalData }\n            };\n            \n            if (await checkAllRequiredSignaturesComplete(updatedPermitData)) {\n                // üöÄ CAMBIO AUTOM√ÅTICO DE PENDIENTE_REVISION ‚Üí EN_EJECUCION\n                if (permitBeforeData.status === 'pendiente_revision') {\n                    updateData['status'] = 'en_ejecucion';\n                }\n            }\n        }\n        \n        await docRef.update(updateData);\n        \n        const permitDoc = await docRef.get();\n        const updatedPermitData = { id: permitDoc.id, ...permitDoc.data() } as Permit;\n        \n        const signatureRoleName = (signatureRoles as any)[role] || role.replace('_', ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n        \n        const message = `${user.displayName || 'Un usuario'} ha firmado el permiso #${updatedPermitData.number} como ${signatureRoleName}.`;\n        const involvedUsers = await getInvolvedUsers(updatedPermitData);\n        \n        for (const uid of involvedUsers) {\n          if (uid !== user.uid) {\n            await createNotification(uid, updatedPermitData, message, 'signature', user);\n          }\n        }\n        \n        // ‚úÖ NOTIFICACI√ìN ESPECIAL SI EL PERMISO PAS√ì AUTOM√ÅTICAMENTE A EN_EJECUCION\n        if (updateData['status'] === 'en_ejecucion') {\n            const executionMessage = `El permiso #${updatedPermitData.number} ha completado todas las aprobaciones requeridas y ahora est√° EN EJECUCI√ìN.`;\n            for (const uid of involvedUsers) {\n                 await createNotification(uid, updatedPermitData, executionMessage, 'approval', user);\n            }\n            \n            // Notificaci√≥n WhatsApp\n            const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n            const permitUrl = `${baseUrl}/permits/${permitId}`;\n            const whatsappMsg = `*¬°PERMISO EN EJECUCI√ìN!* ‚úÖ\n\nüìÑ *N√∫mero:* ${updatedPermitData.number}\nüìç *√Årea:* ${permitBeforeData.generalInfo?.areaEspecifica || 'N/A'}\nüõ†Ô∏è *Tipo:* ${getWorkTypesString(permitBeforeData)}\n\n‚úÖ Todas las firmas requeridas han sido completadas.\nEl permiso est√° ahora EN EJECUCI√ìN.\n\nVer detalles: ${permitUrl}`;\n            \n            await sendWhatsAppNotification(whatsappMsg);\n        }\n\n        revalidatePath(`/permits/${permitId}`);\n        return { success: true };\n\n    } catch (error: any) {\n        console.error(\"‚ùå Error al guardar firma y notificar:\", error);\n        return {\n            success: false,\n            error: error.message || 'No se pudo guardar la firma.'\n        };\n    }\n}\n\n// ‚úÖ FUNCI√ìN CORREGIDA: Verificar si todas las firmas requeridas est√°n completas\nasync function checkAllRequiredSignaturesComplete(\n  permitData: Permit\n): Promise<boolean> {\n    const { approvals } = permitData;\n    \n    // Firma del solicitante es SIEMPRE requerida\n    if (approvals?.solicitante?.status !== 'aprobado') {\n        return false;\n    }\n    \n    // Firma del autorizante es SIEMPRE requerida\n    if (approvals?.autorizante?.status !== 'aprobado') {\n        return false;\n    }\n    \n    // Si hay trabajos en alturas, requiere firma del coordinador\n    if (permitData.trabajoAlturas || permitData.selectedWorkTypes?.alturas) {\n        if (approvals?.coordinador_alturas?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    // Si hay control de energ√≠a, requiere firma de mantenimiento\n    if (permitData.controlEnergia) {\n        if (approvals?.mantenimiento?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    // Si SST es requerido, validar su firma\n    if (permitData.isSSTSignatureRequired) {\n        if (approvals?.lider_sst?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n// ‚úÖ FUNCI√ìN MEJORADA: Validaci√≥n de transiciones de estado\nfunction validateStateTransition(currentStatus: PermitStatus, targetStatus: PermitStatus, userRole: UserRole): { allowed: boolean, reason?: string } {\n    const allowedTransitions: Partial<Record<PermitStatus, Partial<Record<PermitStatus, UserRole[]>>>> = {\n        'borrador': {\n            'pendiente_revision': ['solicitante', 'lider_tarea', 'admin']\n        },\n        'pendiente_revision': {\n            'en_ejecucion': ['autorizante', 'admin'],\n            'rechazado': ['autorizante', 'lider_sst', 'admin']\n        },\n        'en_ejecucion': {\n            'suspendido': ['lider_sst', 'admin'],\n            'cerrado': ['lider_tarea', 'autorizante', 'admin']\n        },\n        'suspendido': {\n            'en_ejecucion': ['lider_sst', 'admin'],\n            'cerrado': ['lider_tarea', 'autorizante', 'admin']\n        },\n        // Mantener compatibilidad con permisos antiguos que tengan estado \"aprobado\"\n        'aprobado': {\n            'en_ejecucion': ['lider_tarea', 'admin'],\n            'rechazado': ['autorizante', 'lider_sst', 'admin']\n        }\n    };\n    \n    const allowedRoles = allowedTransitions[currentStatus]?.[targetStatus];\n    if (!allowedRoles) {\n        return { allowed: false, reason: `Transici√≥n de '${currentStatus}' a '${targetStatus}' no est√° permitida.` };\n    }\n\n    if (!allowedRoles.includes(userRole) && userRole !== 'admin') {\n        return { allowed: false, reason: `Tu rol (${userRole}) no tiene permisos para cambiar el estado a '${targetStatus}'.` };\n    }\n\n    return { allowed: true };\n}\n\nexport async function updatePermitStatus(\n  permitId: string,\n  status: PermitStatus,\n  currentUser: { uid: string, displayName: string | null, role?: UserRole },\n  reason?: string\n) {\n    if (!permitId || !currentUser.uid || !currentUser.role) {\n        return { success: false, error: 'Par√°metros inv√°lidos o usuario sin rol.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas.' };\n    }\n\n    try {\n        const docRef = adminDb.collection('permits').doc(permitId);\n        const permitSnap = await docRef.get();\n        if (!permitSnap.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n        const permitData = permitSnap.data() as Permit;\n        \n        // ‚úÖ Validar transici√≥n de estado\n        const transition = validateStateTransition(permitData.status, status, currentUser.role);\n        if (!transition.allowed) {\n            return { success: false, error: transition.reason };\n        }\n\n        const updateData: UpdateData<Permit> = { status };\n\n        // ‚úÖ Guardar raz√≥n de rechazo\n        if (status === 'rechazado' && reason) {\n            updateData.rejectionReason = reason;\n        }\n        \n        // ‚úÖ Marcar fecha de cierre\n        if (status === 'cerrado') {\n            updateData['closure.fechaCierre'] = FieldValue.serverTimestamp();\n            updateData['closure.terminado'] = 'si';\n        }\n\n        await docRef.update(updateData);\n        \n        const updatedPermitData = { ...permitData, ...updateData, id: permitId } as Permit;\n        const triggeredBy = currentUser;\n        \n        let notificationType: Notification['type'] = 'status_change';\n        let message = `${currentUser.displayName || 'Un usuario'} ha cambiado el estado del permiso #${permitData.number} a: ${getStatusText(status)}.`;\n\n        if (status === 'en_ejecucion') {\n            notificationType = 'approval';\n            message = `El permiso #${permitData.number} ha sido puesto EN EJECUCI√ìN manualmente.`;\n        } else if (status === 'rechazado') {\n            notificationType = 'rejection';\n            message = `${currentUser.displayName || 'Un usuario'} ha rechazado el permiso #${permitData.number}.`;\n            if (reason) message += ` Motivo: ${reason}`;\n        } else if (status === 'cerrado') {\n            notificationType = 'cancellation';\n            message = `${currentUser.displayName || 'Un usuario'} ha cerrado el permiso #${permitData.number}.`;\n        }\n        \n        const involvedUsers = await getInvolvedUsers(updatedPermitData);\n        for (const uid of involvedUsers) {\n             if (uid !== currentUser.uid) {\n                await createNotification(uid, updatedPermitData, message, notificationType, triggeredBy);\n            }\n        }\n\n        const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n        const permitUrl = `${baseUrl}/permits/${permitId}`;\n\n        let messageBody = `*Actualizaci√≥n de Estado - SGTC* üîÑ\nEl estado del permiso *${permitData.number || permitId}* ha cambiado.\n\n*Nuevo Estado:* ${getStatusText(status)}\n\nPuede ver los detalles aqu√≠:\n${permitUrl}`;\n\n        if (status === 'rechazado' && reason) {\n          messageBody += `\\n\\n*Motivo del rechazo:* ${reason}`;\n        }\n        \n        await sendWhatsAppNotification(messageBody);\n        \n        revalidatePath(`/permits/${permitId}`);\n        revalidatePath('/permits');\n        revalidatePath('/dashboard');\n\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"‚ùå Error updating permit status:\", error);\n        return {\n            success: false,\n            error: error.message || 'Could not update permit status.'\n        };\n    }\n}\n\n// ‚úÖ FUNCI√ìN MEJORADA: Validaci√≥n de permisos de firma con orden jer√°rquico\nasync function validateSignaturePermission(\n    permitId: string, \n    signatureRole: string, \n    currentUser: { uid: string, role?: UserRole }\n): Promise<{ allowed: boolean, reason?: string }> {\n    const docRef = adminDb.collection('permits').doc(permitId);\n    const permitDoc = await docRef.get();\n    if (!permitDoc.exists) {\n        return { allowed: false, reason: 'Permiso no encontrado.' };\n    }\n    const permit = permitDoc.data() as Permit;\n    \n    // ‚úÖ Verificar que el permiso est√© en un estado v√°lido para firmar\n    if (!['borrador', 'pendiente_revision'].includes(permit.status)) {\n        return { allowed: false, reason: `No se puede firmar un permiso en estado '${permit.status}'.` };\n    }\n    \n    switch (signatureRole) {\n        case 'coordinador_alturas':\n            // Debe haber trabajo en alturas\n            if (!permit.trabajoAlturas && !permit.selectedWorkTypes?.alturas) {\n                return { allowed: false, reason: 'Esta firma solo aplica para trabajos en alturas.' };\n            }\n            // Solo el creador o admin puede gestionar esta firma\n            if (permit.createdBy !== currentUser.uid && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Solo el creador del permiso puede gestionar esta firma.' };\n            }\n            break;\n            \n        case 'solicitante':\n            if (permit.createdBy !== currentUser.uid && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Solo el creador del permiso puede firmar como solicitante.' };\n            }\n            // ‚úÖ Si hay anexo de alturas, verificar firma del coordinador primero\n            if ((permit.trabajoAlturas || permit.selectedWorkTypes?.alturas) && \n                permit.approvals?.coordinador_alturas?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del Coordinador de Trabajos en Alturas.' };\n            }\n            break;\n            \n        case 'autorizante':\n            if (currentUser.role !== 'autorizante' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de autorizante requerido para esta firma.' };\n            }\n            if (permit.approvals?.solicitante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del solicitante.' };\n            }\n            break;\n            \n        case 'lider_sst':\n            if (currentUser.role !== 'lider_sst' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de L√≠der SST requerido para esta firma.' };\n            }\n            // ‚úÖ Solo requerido si isSSTSignatureRequired es true\n            if (!permit.isSSTSignatureRequired) {\n                return { allowed: false, reason: 'Firma de SST no es requerida para este permiso.' };\n            }\n            if (permit.approvals?.solicitante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del solicitante.' };\n            }\n            break;\n            \n        case 'mantenimiento':\n             if (currentUser.role !== 'mantenimiento' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de Mantenimiento requerido para esta firma.' };\n            }\n            if (!permit.controlEnergia) {\n                return { allowed: false, reason: 'Firma de Mantenimiento solo aplica cuando hay control de energ√≠as.' };\n            }\n            if (permit.approvals?.autorizante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del autorizante.' };\n            }\n            break;\n    }\n    \n    return { allowed: true };\n}\n\nexport async function addDailyValidationSignature(\n  permitId: string, \n  anexoName: string, \n  validationType: 'autoridad' | 'responsable', \n  index: number, \n  data: ValidacionDiaria, \n  user: User\n) {\n  if (!permitId || !anexoName || !validationType || index < 0 || !data || !user) {\n    return { success: false, error: 'Par√°metros inv√°lidos.' };\n  }\n\n  if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const docRef = adminDb.collection('permits').doc(permitId);\n  try {\n    const permitSnap = await docRef.get();\n    if (!permitSnap.exists) {\n      return { success: false, error: 'El permiso no existe.' };\n    }\n    const permitData = permitSnap.data() as Permit;\n\n    // ‚úÖ Verificar que el permiso est√© en ejecuci√≥n para validaciones diarias\n    if (!['en_ejecucion', 'suspendido'].includes(permitData.status)) {\n        return { success: false, error: 'Solo se pueden agregar validaciones diarias en permisos EN EJECUCI√ìN o SUSPENDIDOS.' };\n    }\n\n    const anexoData = (permitData as any)[anexoName];\n    if (!anexoData) {\n      return { success: false, error: `El anexo ${anexoName} no existe en el permiso.` };\n    }\n    \n    const anexoUpdate: any = { ...anexoData };\n    if (!anexoUpdate.validacion) {\n        anexoUpdate.validacion = { autoridad: [], responsable: [] };\n    }\n\n    const validationArray = (anexoUpdate.validacion[validationType] as ValidacionDiaria[]) || [];\n    \n    while (validationArray.length <= index) {\n        validationArray.push({ dia: validationArray.length + 1, nombre: '', fecha: '', firma: '' });\n    }\n\n    validationArray[index] = data;\n    \n    const updatePath = `${anexoName}.validacion.${validationType}`;\n    \n    await docRef.update({\n      [updatePath]: validationArray,\n    });\n\n    const fullPermitData = { id: docRef.id, ...permitData } as Permit;\n    const anexoDisplayName = anexoName.replace('anexo', 'Anexo ');\n    const validationRoleName = validationType === 'autoridad' ? 'Autoridad del √Årea' : 'Responsable del Trabajo';\n    const day = index + 1;\n\n    const message = `${user.displayName || 'Un usuario'} ha realizado la validaci√≥n diaria (${validationRoleName}) para el D√çA ${day} del ${anexoDisplayName} en el permiso #${fullPermitData.number}.`;\n    const involvedUsers = await getInvolvedUsers(fullPermitData);\n    for (const uid of involvedUsers) {\n      if (uid !== user.uid) {\n        await createNotification(uid, fullPermitData, message, 'status_change', { uid: user.uid, displayName: user.displayName || null });\n      }\n    }\n\n    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n    const permitUrl = `${baseUrl}/permits/${permitId}`;\n    const whatsappMessage = `*Validaci√≥n Diaria - SGTC* ‚úçÔ∏è\nSe ha registrado una nueva firma de validaci√≥n diaria.\n\nüìÑ *Permiso:* ${fullPermitData.number || 'N/A'}\nüóìÔ∏è *D√≠a:* ${day}\nüë§ *Firmante:* ${user.displayName || 'N/A'}\n‚úÖ *Rol:* ${validationRoleName}\nüìã *Anexo:* ${anexoDisplayName}\n\nPuede ver los detalles aqu√≠:\n${permitUrl}`;\n    \n    await sendWhatsAppNotification(whatsappMessage);\n\n    revalidatePath(`/permits/${permitId}`);\n    return { success: true };\n\n  } catch (error: any) {\n    console.error(\"‚ùå Error al guardar la validaci√≥n diaria:\", error);\n    return { success: false, error: 'No se pudo guardar la firma de validaci√≥n.' };\n  }\n}\n\nexport async function addWorkerSignature(permitId: string, workerIndex: number, signatureType: 'firmaApertura' | 'firmaCierre', signatureDataUrl: string) {\n    if (!permitId || workerIndex < 0 || !signatureType || !signatureDataUrl) {\n        return { success: false, error: 'Faltan par√°metros.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n    }\n\n    const docRef = adminDb.collection('permits').doc(permitId);\n    try {\n        const permitSnap = await docRef.get();\n        if (!permitSnap.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n\n        const permitData = permitSnap.data() as Permit;\n        \n        // ‚úÖ CORRECCI√ìN: Validaci√≥n de estado corregida para firma de apertura\n        if (signatureType === 'firmaApertura' && !['pendiente_revision', 'aprobado', 'en_ejecucion'].includes(permitData.status)) {\n            return { success: false, error: 'Solo se puede firmar apertura cuando el permiso est√° pendiente, aprobado o en ejecuci√≥n.' };\n        }\n        if (signatureType === 'firmaCierre' && !['en_ejecucion', 'suspendido'].includes(permitData.status)) {\n            return { success: false, error: 'Solo se puede firmar cierre en permisos EN EJECUCI√ìN o SUSPENDIDOS.' };\n        }\n        \n        const workers = permitData.workers ? [...permitData.workers] : [];\n\n        if (workerIndex >= workers.length) {\n            return { success: false, error: '√çndice de trabajador inv√°lido.' };\n        }\n\n        const signatureField = signatureType === 'firmaApertura' ? 'firmaApertura' : 'firmaCierre';\n        const dateField = signatureType === 'firmaApertura' ? 'fechaFirmaApertura' : 'fechaFirmaCierre';\n\n        workers[workerIndex] = {\n            ...workers[workerIndex],\n            [signatureField]: signatureDataUrl,\n            [dateField]: new Date().toISOString(), \n        };\n\n        await docRef.update({ workers: workers });\n\n        revalidatePath(`/permits/${permitId}`);\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"Error al guardar la firma del trabajador:\", error);\n        return { success: false, error: 'No se pudo guardar la firma.' };\n    }\n}\n"],"names":[],"mappings":";;;;;;IA+qBsB,8BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 2202, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/permits/%5Bid%5D/components/DailyValidationTable.tsx"],"sourcesContent":["'use client';\nimport { useState } from 'react';\nimport type { Permit, User, ValidacionDiaria } from '@/types';\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\nimport { SignaturePad } from '@/components/ui/signature-pad';\nimport { useUser } from '@/hooks/use-user';\nimport { useToast } from '@/hooks/use-toast';\nimport { addDailyValidationSignature } from '../../actions';\nimport Image from 'next/image';\nimport { Signature, Plus } from 'lucide-react';\nimport { differenceInCalendarDays, format, parseISO } from 'date-fns';\n\ninterface DailyValidationTableProps {\n  permit: Permit;\n  anexoName: 'anexoAltura' | 'anexoConfinado' | 'anexoIzaje' | 'anexoExcavaciones';\n  title: string;\n}\n\nexport function DailyValidationTable({ permit, anexoName, title }: DailyValidationTableProps) {\n  const { user } = useUser();\n  const { toast } = useToast();\n\n  const [isSigning, setIsSigning] = useState(false);\n  const [signingInfo, setSigningInfo] = useState<{ type: 'autoridad' | 'responsable'; index: number } | null>(null);\n\n  const anexoData = permit[anexoName] as any;\n  if (!anexoData) return null;\n  \n  const validaciones = anexoData.validacion || { autoridad: [], responsable: [] };\n\n  const handleOpenSignatureModal = (type: 'autoridad' | 'responsable', index: number) => {\n    setSigningInfo({ type, index });\n    setIsSigning(true);\n  };\n  \n  const handleSaveSignature = async (signatureDataUrl: string) => {\n    if (!signingInfo || !user) return;\n\n    const { type, index } = signingInfo;\n    \n    const newValidationEntry: ValidacionDiaria = {\n        dia: index + 1,\n        fecha: new Date().toISOString(),\n        nombre: user.displayName || 'N/A',\n        firma: signatureDataUrl,\n    };\n    \n    const result = await addDailyValidationSignature(permit.id, anexoName, type, index, newValidationEntry, user as User);\n    \n    if (result.success) {\n      toast({ title: 'Firma de Validaci√≥n Guardada' });\n    } else {\n      toast({ variant: 'destructive', title: 'Error', description: result.error });\n    }\n    \n    setIsSigning(false);\n    setSigningInfo(null);\n  };\n  \n  const canSign = (type: 'autoridad' | 'responsable', validationEntry: ValidacionDiaria | undefined) => {\n      if (!user) return false;\n      if (permit.status !== 'en_ejecucion' && permit.status !== 'suspendido') return false;\n      if (validationEntry?.firma) return false;\n      if (type === 'autoridad' && (user?.role === 'autorizante' || user?.role === 'admin')) return true;\n      if (type === 'responsable' && (user?.role === 'lider_tarea' || user?.role === 'solicitante' || user?.role === 'admin')) return true;\n      return false;\n  }\n\n  const getValidDate = (dateString: string | undefined): Date | null => {\n    if (!dateString) return null;\n    const date = parseISO(dateString);\n    return isNaN(date.getTime()) ? null : date;\n  }\n\n  const validFrom = getValidDate(permit.generalInfo.validFrom);\n  const validUntil = getValidDate(permit.generalInfo.validUntil);\n\n  if (!validFrom || !validUntil) {\n    return (\n        <Card>\n            <CardHeader>\n                <CardTitle>{title}</CardTitle>\n            </CardHeader>\n            <CardContent>\n                <p className=\"text-muted-foreground\">Fechas de validez del permiso no est√°n definidas correctamente.</p>\n            </CardContent>\n        </Card>\n    )\n  }\n\n  const durationDays = differenceInCalendarDays(\n    validUntil,\n    validFrom\n  ) + 1;\n\n  const validationDays = Array.from({ length: durationDays > 0 ? durationDays : 0 }, (_, i) => i);\n\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle>{title}</CardTitle>\n      </CardHeader>\n      <CardContent>\n        <Table>\n          <TableHeader>\n            <TableRow>\n              <TableHead>D√≠a</TableHead>\n              <TableHead>Fecha</TableHead>\n              <TableHead>Autoridad del √Årea (Firma)</TableHead>\n              <TableHead>Responsable del Trabajo (Firma)</TableHead>\n            </TableRow>\n          </TableHeader>\n          <TableBody>\n            {validationDays.map(dayIndex => {\n                const autoridadValidation = validaciones.autoridad[dayIndex];\n                const responsableValidation = validaciones.responsable[dayIndex];\n                const validationDate = new Date(validFrom);\n                validationDate.setDate(validationDate.getDate() + dayIndex);\n\n              return (\n                <TableRow key={dayIndex}>\n                  <TableCell>{dayIndex + 1}</TableCell>\n                  <TableCell>{format(validationDate, 'dd/MM/yyyy')}</TableCell>\n                  <TableCell>\n                    {autoridadValidation?.firma ? (\n                      <div className=\"flex items-center gap-2\">\n                        <Image src={autoridadValidation.firma} alt=\"Firma\" width={80} height={40} className=\"bg-white border rounded\" />\n                        <span className=\"text-xs\">{autoridadValidation.nombre}</span>\n                      </div>\n                    ) : (\n                       canSign('autoridad', autoridadValidation) && <Button size=\"sm\" variant=\"outline\" onClick={() => handleOpenSignatureModal('autoridad', dayIndex)}> <Signature className=\"mr-2 h-4 w-4\"/>Firmar</Button>\n                    )}\n                  </TableCell>\n                  <TableCell>\n                    {responsableValidation?.firma ? (\n                       <div className=\"flex items-center gap-2\">\n                         <Image src={responsableValidation.firma} alt=\"Firma\" width={80} height={40} className=\"bg-white border rounded\" />\n                         <span className=\"text-xs\">{responsableValidation.nombre}</span>\n                       </div>\n                    ) : (\n                       canSign('responsable', responsableValidation) && <Button size=\"sm\" variant=\"outline\" onClick={() => handleOpenSignatureModal('responsable', dayIndex)}><Signature className=\"mr-2 h-4 w-4\"/>Firmar</Button>\n                    )}\n                  </TableCell>\n                </TableRow>\n              );\n            })}\n          </TableBody>\n        </Table>\n      </CardContent>\n      <Dialog open={isSigning} onOpenChange={setIsSigning}>\n          <DialogContent>\n              <DialogHeader><DialogTitle>Realizar Firma de Validaci√≥n</DialogTitle></DialogHeader>\n              <SignaturePad onSave={handleSaveSignature} />\n          </DialogContent>\n      </Dialog>\n    </Card>\n  );\n}\n"],"names":[],"mappings":";;;;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AApBA;;;;;;;;;;;;;;AA4BO,SAAS,qBAAqB,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAA6B;IAC1F,MAAM,EAAE,IAAI,EAAE,GAAG,CAAA,GAAA,4HAAA,CAAA,UAAO,AAAD;IACvB,MAAM,EAAE,KAAK,EAAE,GAAG,CAAA,GAAA,4HAAA,CAAA,WAAQ,AAAD;IAEzB,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAC3C,MAAM,CAAC,aAAa,eAAe,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAA+D;IAE5G,MAAM,YAAY,MAAM,CAAC,UAAU;IACnC,IAAI,CAAC,WAAW,OAAO;IAEvB,MAAM,eAAe,UAAU,UAAU,IAAI;QAAE,WAAW,EAAE;QAAE,aAAa,EAAE;IAAC;IAE9E,MAAM,2BAA2B,CAAC,MAAmC;QACnE,eAAe;YAAE;YAAM;QAAM;QAC7B,aAAa;IACf;IAEA,MAAM,sBAAsB,OAAO;QACjC,IAAI,CAAC,eAAe,CAAC,MAAM;QAE3B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG;QAExB,MAAM,qBAAuC;YACzC,KAAK,QAAQ;YACb,OAAO,IAAI,OAAO,WAAW;YAC7B,QAAQ,KAAK,WAAW,IAAI;YAC5B,OAAO;QACX;QAEA,MAAM,SAAS,MAAM,CAAA,GAAA,6JAAA,CAAA,8BAA2B,AAAD,EAAE,OAAO,EAAE,EAAE,WAAW,MAAM,OAAO,oBAAoB;QAExG,IAAI,OAAO,OAAO,EAAE;YAClB,MAAM;gBAAE,OAAO;YAA+B;QAChD,OAAO;YACL,MAAM;gBAAE,SAAS;gBAAe,OAAO;gBAAS,aAAa,OAAO,KAAK;YAAC;QAC5E;QAEA,aAAa;QACb,eAAe;IACjB;IAEA,MAAM,UAAU,CAAC,MAAmC;QAChD,IAAI,CAAC,MAAM,OAAO;QAClB,IAAI,OAAO,MAAM,KAAK,kBAAkB,OAAO,MAAM,KAAK,cAAc,OAAO;QAC/E,IAAI,iBAAiB,OAAO,OAAO;QACnC,IAAI,SAAS,eAAe,CAAC,MAAM,SAAS,iBAAiB,MAAM,SAAS,OAAO,GAAG,OAAO;QAC7F,IAAI,SAAS,iBAAiB,CAAC,MAAM,SAAS,iBAAiB,MAAM,SAAS,iBAAiB,MAAM,SAAS,OAAO,GAAG,OAAO;QAC/H,OAAO;IACX;IAEA,MAAM,eAAe,CAAC;QACpB,IAAI,CAAC,YAAY,OAAO;QACxB,MAAM,OAAO,CAAA,GAAA,wIAAA,CAAA,WAAQ,AAAD,EAAE;QACtB,OAAO,MAAM,KAAK,OAAO,MAAM,OAAO;IACxC;IAEA,MAAM,YAAY,aAAa,OAAO,WAAW,CAAC,SAAS;IAC3D,MAAM,aAAa,aAAa,OAAO,WAAW,CAAC,UAAU;IAE7D,IAAI,CAAC,aAAa,CAAC,YAAY;QAC7B,qBACI,8OAAC,gIAAA,CAAA,OAAI;;8BACD,8OAAC,gIAAA,CAAA,aAAU;8BACP,cAAA,8OAAC,gIAAA,CAAA,YAAS;kCAAE;;;;;;;;;;;8BAEhB,8OAAC,gIAAA,CAAA,cAAW;8BACR,cAAA,8OAAC;wBAAE,WAAU;kCAAwB;;;;;;;;;;;;;;;;;IAInD;IAEA,MAAM,eAAe,CAAA,GAAA,wJAAA,CAAA,2BAAwB,AAAD,EAC1C,YACA,aACE;IAEJ,MAAM,iBAAiB,MAAM,IAAI,CAAC;QAAE,QAAQ,eAAe,IAAI,eAAe;IAAE,GAAG,CAAC,GAAG,IAAM;IAG7F,qBACE,8OAAC,gIAAA,CAAA,OAAI;;0BACH,8OAAC,gIAAA,CAAA,aAAU;0BACT,cAAA,8OAAC,gIAAA,CAAA,YAAS;8BAAE;;;;;;;;;;;0BAEd,8OAAC,gIAAA,CAAA,cAAW;0BACV,cAAA,8OAAC,iIAAA,CAAA,QAAK;;sCACJ,8OAAC,iIAAA,CAAA,cAAW;sCACV,cAAA,8OAAC,iIAAA,CAAA,WAAQ;;kDACP,8OAAC,iIAAA,CAAA,YAAS;kDAAC;;;;;;kDACX,8OAAC,iIAAA,CAAA,YAAS;kDAAC;;;;;;kDACX,8OAAC,iIAAA,CAAA,YAAS;kDAAC;;;;;;kDACX,8OAAC,iIAAA,CAAA,YAAS;kDAAC;;;;;;;;;;;;;;;;;sCAGf,8OAAC,iIAAA,CAAA,YAAS;sCACP,eAAe,GAAG,CAAC,CAAA;gCAChB,MAAM,sBAAsB,aAAa,SAAS,CAAC,SAAS;gCAC5D,MAAM,wBAAwB,aAAa,WAAW,CAAC,SAAS;gCAChE,MAAM,iBAAiB,IAAI,KAAK;gCAChC,eAAe,OAAO,CAAC,eAAe,OAAO,KAAK;gCAEpD,qBACE,8OAAC,iIAAA,CAAA,WAAQ;;sDACP,8OAAC,iIAAA,CAAA,YAAS;sDAAE,WAAW;;;;;;sDACvB,8OAAC,iIAAA,CAAA,YAAS;sDAAE,CAAA,GAAA,sJAAA,CAAA,SAAM,AAAD,EAAE,gBAAgB;;;;;;sDACnC,8OAAC,iIAAA,CAAA,YAAS;sDACP,qBAAqB,sBACpB,8OAAC;gDAAI,WAAU;;kEACb,8OAAC,6HAAA,CAAA,UAAK;wDAAC,KAAK,oBAAoB,KAAK;wDAAE,KAAI;wDAAQ,OAAO;wDAAI,QAAQ;wDAAI,WAAU;;;;;;kEACpF,8OAAC;wDAAK,WAAU;kEAAW,oBAAoB,MAAM;;;;;;;;;;;uDAGtD,QAAQ,aAAa,sCAAwB,8OAAC,kIAAA,CAAA,SAAM;gDAAC,MAAK;gDAAK,SAAQ;gDAAU,SAAS,IAAM,yBAAyB,aAAa;;oDAAW;kEAAC,8OAAC,4MAAA,CAAA,YAAS;wDAAC,WAAU;;;;;;oDAAgB;;;;;;;;;;;;sDAG5L,8OAAC,iIAAA,CAAA,YAAS;sDACP,uBAAuB,sBACrB,8OAAC;gDAAI,WAAU;;kEACb,8OAAC,6HAAA,CAAA,UAAK;wDAAC,KAAK,sBAAsB,KAAK;wDAAE,KAAI;wDAAQ,OAAO;wDAAI,QAAQ;wDAAI,WAAU;;;;;;kEACtF,8OAAC;wDAAK,WAAU;kEAAW,sBAAsB,MAAM;;;;;;;;;;;uDAGzD,QAAQ,eAAe,wCAA0B,8OAAC,kIAAA,CAAA,SAAM;gDAAC,MAAK;gDAAK,SAAQ;gDAAU,SAAS,IAAM,yBAAyB,eAAe;;kEAAW,8OAAC,4MAAA,CAAA,YAAS;wDAAC,WAAU;;;;;;oDAAgB;;;;;;;;;;;;;mCApBpL;;;;;4BAyBnB;;;;;;;;;;;;;;;;;0BAIN,8OAAC,kIAAA,CAAA,SAAM;gBAAC,MAAM;gBAAW,cAAc;0BACnC,cAAA,8OAAC,kIAAA,CAAA,gBAAa;;sCACV,8OAAC,kIAAA,CAAA,eAAY;sCAAC,cAAA,8OAAC,kIAAA,CAAA,cAAW;0CAAC;;;;;;;;;;;sCAC3B,8OAAC,4IAAA,CAAA,eAAY;4BAAC,QAAQ;;;;;;;;;;;;;;;;;;;;;;;AAKpC","debugId":null}},
    {"offset": {"line": 2591, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/permits/%5Bid%5D/components/PermitDetails.tsx"],"sourcesContent":["'use client';\nimport { useState } from 'react';\nimport type { Permit, PermitStatus, UserRole } from '@/types';\nimport { useUser } from '@/hooks/use-user';\nimport { Button } from '@/components/ui/button';\nimport {\n  FileText,\n  User,\n  Clock,\n  Settings,\n  Shield,\n  HardHat,\n  Eye,\n  CheckCircle,\n  XCircle,\n  Play,\n  Pause,\n  Lock,\n  Download,\n  Send,\n  Loader2,\n  MessageCircle,\n  AlertTriangle,\n} from 'lucide-react';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\nimport { SignatureCard } from './SignatureCard';\nimport { StatusBadge } from './StatusBadge';\nimport { useToast } from '@/hooks/use-toast';\nimport { updatePermitStatus } from '../../actions';\nimport { generateCompleteWorkPermitPDF } from '@/lib/pdf-generator';\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogDescription,\n  DialogFooter,\n  DialogClose\n} from '@/components/ui/dialog';\nimport { Textarea } from '@/components/ui/textarea';\nimport { WorkerSignatures } from './WorkerSignatures';\nimport { DailyValidationTable } from './DailyValidationTable';\nimport { format, parseISO } from 'date-fns';\nimport { es } from 'date-fns/locale';\n\ninterface PermitDetailsProps {\n  permit: Permit;\n}\n\nconst signatureConfig = {\n  coordinador_alturas: {\n    title: 'COORDINADOR DE TRABAJOS EN ALTURAS',\n    required: (permit: Permit) => !!permit.selectedWorkTypes?.alturas,\n    canSign: (permit: Permit, user: any) => \n        user && (user.role === 'admin' || permit.createdBy === user.uid) &&\n        permit.status === 'pendiente_revision' &&\n        !permit.approvals?.coordinador_alturas?.firmaApertura,\n    tooltip: 'Solo el creador del permiso puede gestionar esta firma.'\n  },\n  solicitante: {\n    title: 'QUIEN SOLICITA (L√çDER A CARGO DEL EQUIPO EJECUTANTE)',\n    required: () => true,\n    canSign: (permit: Permit, user: any) => \n        user && (user.role === 'admin' || permit.createdBy === user.uid) &&\n        permit.status === 'pendiente_revision' &&\n        !permit.approvals?.solicitante?.firmaApertura,\n    tooltip: 'Se requiere la firma del creador del permiso.'\n  },\n  autorizante: {\n    title: 'QUIEN AUTORIZA (JEFES Y DUE√ëOS DE AREA)',\n    required: () => true,\n    canSign: (permit: Permit, user: any) =>\n      user && (user.role === 'admin' || user.role === 'autorizante') &&\n      permit.status === 'pendiente_revision' &&\n      !!permit.approvals.solicitante?.firmaApertura &&\n      !permit.approvals.autorizante?.firmaApertura,\n    tooltip: 'Se requiere primero la firma del Solicitante. Solo roles de Autorizante o Admin.'\n  },\n  mantenimiento: {\n    title: 'PERSONAL DE MANTENIMIENTO',\n    required: (permit: Permit) => !!permit.selectedWorkTypes?.energia,\n    canSign: (permit: Permit, user: any) =>\n      user && (user.role === 'admin' || user.role === 'mantenimiento') &&\n      permit.status === 'pendiente_revision' &&\n      !!permit.approvals.autorizante?.firmaApertura &&\n      !permit.approvals.mantenimiento?.firmaApertura,\n    tooltip: 'Solo aplica para Control de Energ√≠as y requiere firma previa del Autorizante.'\n  },\n  lider_sst: {\n    title: 'FIRMA SST (SEGURIDAD Y SALUD EN EL TRABAJO)',\n    required: (permit: Permit) => !!permit.isSSTSignatureRequired,\n    canSign: (permit: Permit, user: any) =>\n      user && (user.role === 'admin' || user.role === 'lider_sst') &&\n      permit.status === 'pendiente_revision' &&\n      !!permit.approvals.solicitante?.firmaApertura &&\n      !permit.approvals.lider_sst?.firmaApertura,\n    tooltip: 'Firma requerida para tareas no estandarizadas. Solo rol L√≠der SST o Admin.'\n  },\n};\n\n\nexport function PermitDetails({ permit }: PermitDetailsProps) {\n  const { user } = useUser();\n  const { toast } = useToast();\n\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [rejectionReason, setRejectionReason] = useState('');\n  const [isRejectionModalOpen, setIsRejectionModalOpen] = useState(false);\n  \n  const canUserApprove = user && (user.role === 'autorizante' || user.role === 'admin');\n  const canUserReject = canUserApprove || (user && user.role === 'lider_sst');\n  const canUserStart = user && (user.role === 'lider_tarea' || user.role === 'admin');\n  const canUserSuspend = user && (user.role === 'lider_sst' || user.role === 'admin');\n  const canUserClose = canUserStart;\n\n  const handleStatusUpdate = async (newStatus: PermitStatus, reason?: string) => {\n    if (!user || !user.role) return;\n\n    setIsSubmitting(true);\n    const result = await updatePermitStatus(permit.id, newStatus, { uid: user.uid, displayName: user.displayName, role: user.role }, reason);\n    setIsSubmitting(false);\n\n    if (result.success) {\n      toast({ title: 'Estado Actualizado', description: `El permiso ha sido movido a: ${newStatus}` });\n      if (isRejectionModalOpen) setIsRejectionModalOpen(false);\n    } else {\n      toast({ variant: 'destructive', title: 'Error', description: result.error });\n    }\n  };\n\n  const handleDownloadPdf = async () => {\n    toast({ title: 'Generando PDF...', description: 'Por favor espere un momento.' });\n    try {\n        await generateCompleteWorkPermitPDF(permit);\n    } catch (e: any) {\n        toast({ variant: 'destructive', title: 'Error al generar PDF', description: e.message });\n    }\n  };\n\n  const allSignaturesDone = () => {\n    const requiredSigs = Object.entries(signatureConfig).filter(([_, config]) => config.required(permit));\n    return requiredSigs.every(([key]) => permit.approvals[key as keyof typeof permit.approvals]?.status === 'aprobado');\n  };\n  \n  const formattedDate = (dateString: string | undefined) => {\n    if (!dateString) return 'N/A';\n    try {\n        return format(parseISO(dateString), \"dd/MM/yyyy 'a las' HH:mm\", { locale: es });\n    } catch {\n        return 'Fecha inv√°lida';\n    }\n  };\n\n  const renderAnexo = (anexoData: any, title: string) => {\n    if (!anexoData) return null;\n    return (\n      <Card>\n        <CardHeader>\n          <CardTitle>{title}</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <pre className=\"text-xs whitespace-pre-wrap font-sans bg-muted p-4 rounded-md\">\n            {JSON.stringify(anexoData, null, 2)}\n          </pre>\n        </CardContent>\n      </Card>\n    );\n  };\n\n  return (\n    <div className=\"flex flex-1 flex-col gap-4 p-4 md:gap-8 md:p-8\">\n      {/* Header */}\n      <div className=\"flex flex-col md:flex-row items-start md:items-center justify-between gap-4\">\n        <div>\n          <div className=\"flex items-center gap-3\">\n             <FileText className=\"h-8 w-8 text-primary\" />\n             <div>\n                <h1 className=\"text-2xl md:text-3xl font-bold tracking-tight\">\n                  Permiso #{permit.number || permit.id.substring(0, 8)}\n                </h1>\n                <p className=\"text-muted-foreground\">{permit.generalInfo.workDescription}</p>\n             </div>\n          </div>\n        </div>\n        <div className=\"flex items-center gap-2\">\n            <StatusBadge status={permit.status} />\n            <Button onClick={handleDownloadPdf} variant=\"outline\" size=\"sm\">\n                <Download className=\"mr-2 h-4 w-4\" />\n                PDF\n            </Button>\n        </div>\n      </div>\n\n      {/* Main Grid */}\n      <div className=\"grid gap-6 lg:grid-cols-3\">\n        {/* Left Column - Main Details */}\n        <div className=\"lg:col-span-2 space-y-6\">\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\"><User /> Informaci√≥n del Solicitante</CardTitle>\n            </CardHeader>\n            <CardContent className=\"grid grid-cols-2 md:grid-cols-3 gap-4 text-sm\">\n                <div><p className=\"font-semibold\">Nombre</p><p>{permit.user?.displayName || 'N/A'}</p></div>\n                <div><p className=\"font-semibold\">Email</p><p>{permit.user?.email || 'N/A'}</p></div>\n                <div><p className=\"font-semibold\">Empresa</p><p>{permit.generalInfo?.empresa || 'N/A'}</p></div>\n                <div><p className=\"font-semibold\">Creado</p><p>{formattedDate(permit.createdAt as unknown as string)}</p></div>\n                <div><p className=\"font-semibold\">V√°lido Desde</p><p>{formattedDate(permit.generalInfo?.validFrom)}</p></div>\n                <div><p className=\"font-semibold\">V√°lido Hasta</p><p>{formattedDate(permit.generalInfo?.validUntil)}</p></div>\n            </CardContent>\n          </Card>\n\n          <div className=\"space-y-6\">\n             {Object.entries(signatureConfig).map(([key, config]) => {\n                if (config.required(permit)) {\n                    return (\n                        <SignatureCard\n                            key={key}\n                            title={config.title}\n                            approval={permit.approvals[key as keyof typeof permit.approvals]}\n                            canSign={config.canSign(permit, user)}\n                            permitId={permit.id}\n                            signatureRole={key as any}\n                            disabled={permit.status !== 'pendiente_revision'}\n                            tooltip={config.tooltip}\n                        />\n                    )\n                }\n                return null;\n             })}\n          </div>\n\n          <WorkerSignatures permit={permit} />\n\n          {permit.selectedWorkTypes.alturas && <DailyValidationTable permit={permit} anexoName=\"anexoAltura\" title=\"Validaci√≥n Diaria (Alturas)\" />}\n          {permit.selectedWorkTypes.confinado && <DailyValidationTable permit={permit} anexoName=\"anexoConfinado\" title=\"Validaci√≥n Diaria (Esp. Confinados)\" />}\n\n        </div>\n\n        {/* Right Column - Actions */}\n        <div className=\"lg:col-span-1 space-y-6\">\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\"><Settings /> Acciones del Permiso</CardTitle>\n              <CardDescription>Gestione el ciclo de vida de este permiso.</CardDescription>\n            </CardHeader>\n            <CardContent className=\"space-y-3\">\n              {/* Approve */}\n              {permit.status === 'pendiente_revision' && (\n                <Button \n                    className=\"w-full bg-green-600 hover:bg-green-700\" \n                    onClick={() => handleStatusUpdate('aprobado')} \n                    disabled={!canUserApprove || !allSignaturesDone() || isSubmitting}\n                >\n                  {isSubmitting ? <Loader2 className=\"animate-spin\" /> : <CheckCircle />}\n                  <span>Aprobar Permiso</span>\n                </Button>\n              )}\n               {/* Reject */}\n              {permit.status === 'pendiente_revision' && (\n                <Button \n                    variant=\"destructive\" \n                    className=\"w-full\"\n                    onClick={() => setIsRejectionModalOpen(true)}\n                    disabled={!canUserReject || isSubmitting}\n                >\n                  <XCircle /><span>Rechazar Permiso</span>\n                </Button>\n              )}\n              {/* Start */}\n              {permit.status === 'aprobado' && (\n                 <Button className=\"w-full\" onClick={() => handleStatusUpdate('en_ejecucion')} disabled={!canUserStart || isSubmitting}>\n                   {isSubmitting ? <Loader2 className=\"animate-spin\" /> : <Play />}\n                   <span>Iniciar Ejecuci√≥n</span>\n                 </Button>\n              )}\n              {/* Suspend */}\n              {permit.status === 'en_ejecucion' && (\n                 <Button variant=\"secondary\" className=\"w-full\" onClick={() => handleStatusUpdate('suspendido')} disabled={!canUserSuspend || isSubmitting}>\n                   {isSubmitting ? <Loader2 className=\"animate-spin\" /> : <Pause />}\n                   <span>Suspender</span>\n                 </Button>\n              )}\n              {/* Resume */}\n              {permit.status === 'suspendido' && (\n                 <Button className=\"w-full\" onClick={() => handleStatusUpdate('en_ejecucion')} disabled={!canUserSuspend || isSubmitting}>\n                   {isSubmitting ? <Loader2 className=\"animate-spin\" /> : <Play />}\n                   <span>Reanudar Ejecuci√≥n</span>\n                 </Button>\n              )}\n               {/* Close */}\n              {(permit.status === 'en_ejecucion' || permit.status === 'suspendido') && (\n                 <Button variant=\"default\" className=\"w-full\" onClick={() => handleStatusUpdate('cerrado')} disabled={!canUserClose || isSubmitting}>\n                    {isSubmitting ? <Loader2 className=\"animate-spin\" /> : <Lock />}\n                    <span>Cerrar Permiso</span>\n                 </Button>\n              )}\n\n              {permit.status !== 'pendiente_revision' && permit.status !== 'aprobado' && permit.status !== 'en_ejecucion' && permit.status !== 'suspendido' && (\n                  <p className=\"text-sm text-muted-foreground text-center\">No hay acciones disponibles para un permiso en estado '{permit.status}'.</p>\n              )}\n\n            </CardContent>\n          </Card>\n          {/* Annexes */}\n          <Card>\n             <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\"><FileText /> Anexos y Detalles</CardTitle>\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              {renderAnexo(permit.anexoATS, 'Anexo ATS')}\n              {permit.selectedWorkTypes.alturas && renderAnexo(permit.anexoAltura, 'Anexo Trabajo en Alturas')}\n              {permit.selectedWorkTypes.confinado && renderAnexo(permit.anexoConfinado, 'Anexo Espacios Confinados')}\n              {permit.selectedWorkTypes.energia && renderAnexo(permit.anexoEnergias, 'Anexo Control de Energ√≠as')}\n              {permit.selectedWorkTypes.izaje && renderAnexo(permit.anexoIzaje, 'Anexo Izaje de Cargas')}\n              {permit.selectedWorkTypes.excavacion && renderAnexo(permit.anexoExcavaciones, 'Anexo Excavaciones')}\n              {renderAnexo(permit.eppEmergencias, 'EPP y Emergencias')}\n            </CardContent>\n          </Card>\n        </div>\n      </div>\n      \n       {/* Rejection Modal */}\n        <Dialog open={isRejectionModalOpen} onOpenChange={setIsRejectionModalOpen}>\n            <DialogContent>\n                <DialogHeader>\n                    <DialogTitle className=\"flex items-center gap-2\"><AlertTriangle/> Rechazar Permiso</DialogTitle>\n                    <DialogDescription>\n                        Por favor, proporcione un motivo claro para el rechazo. Esta informaci√≥n ser√° enviada al solicitante.\n                    </DialogDescription>\n                </DialogHeader>\n                <Textarea \n                    placeholder=\"Ej: Faltan equipos de protecci√≥n personal especificados en el ATS...\"\n                    value={rejectionReason}\n                    onChange={(e) => setRejectionReason(e.target.value)}\n                    rows={4}\n                />\n                <DialogFooter>\n                    <DialogClose asChild>\n                        <Button variant=\"outline\" disabled={isSubmitting}>Cancelar</Button>\n                    </DialogClose>\n                    <Button \n                        variant=\"destructive\"\n                        onClick={() => handleStatusUpdate('rechazado', rejectionReason)}\n                        disabled={isSubmitting || !rejectionReason.trim()}\n                    >\n                       {isSubmitting ? <Loader2 className=\"animate-spin\" /> : <XCircle />}\n                       Confirmar Rechazo\n                    </Button>\n                </DialogFooter>\n            </DialogContent>\n        </Dialog>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3513, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/errors.ts"],"sourcesContent":["\nexport type SecurityRuleContext = {\n  path: string;\n  operation: 'get' | 'list' | 'create' | 'update' | 'delete' | 'write';\n  requestResourceData?: any;\n};\n\nexport class FirestorePermissionError extends Error {\n  context: SecurityRuleContext;\n\n  constructor(context: SecurityRuleContext) {\n    const message = `FirestoreError: Missing or insufficient permissions. The following request was denied by Firestore Security Rules:\\n${JSON.stringify(\n      {\n        context,\n      },\n      null,\n      2\n    )}`;\n    super(message);\n    this.name = 'FirestorePermissionError';\n    this.context = context;\n\n    // This is to make the error message more readable in the console\n    Object.setPrototypeOf(this, FirestorePermissionError.prototype);\n  }\n}\n"],"names":[],"mappings":";;;AAOO,MAAM,iCAAiC;IAC5C,QAA6B;IAE7B,YAAY,OAA4B,CAAE;QACxC,MAAM,UAAU,CAAC,oHAAoH,EAAE,KAAK,SAAS,CACnJ;YACE;QACF,GACA,MACA,IACC;QACH,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,OAAO,GAAG;QAEf,iEAAiE;QACjE,OAAO,cAAc,CAAC,IAAI,EAAE,yBAAyB,SAAS;IAChE;AACF","debugId":null}},
    {"offset": {"line": 3535, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/permits/%5Bid%5D/page.tsx"],"sourcesContent":["'use client';\nimport { useState, useEffect } from 'react';\nimport { useParams } from 'next/navigation';\nimport { doc, onSnapshot } from 'firebase/firestore';\nimport { db } from '@/lib/firebase';\nimport type { Permit } from '@/types';\nimport { PermitDetails } from './components/PermitDetails';\nimport { Loader2 } from 'lucide-react';\nimport { useToast } from '@/hooks/use-toast';\nimport { useUser } from '@/hooks/use-user';\nimport { errorEmitter } from '@/lib/error-emitter';\nimport { FirestorePermissionError } from '@/lib/errors';\n\nexport default function PermitDetailPage() {\n  const params = useParams();\n  const { toast } = useToast();\n  const { user } = useUser();\n  const permitId = Array.isArray(params.id) ? params.id[0] : params.id;\n\n  const [permit, setPermit] = useState<Permit | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (!permitId) {\n      setLoading(false);\n      return;\n    }\n    \n    if (!user) return; // Wait for user to be loaded\n\n    const docRef = doc(db, 'permits', permitId);\n    const unsubscribe = onSnapshot(docRef, (docSnap) => {\n      if (docSnap.exists()) {\n        const data = docSnap.data();\n        \n        // Convert Firestore Timestamps to serializable strings for the state\n        const sanitizedData = JSON.parse(JSON.stringify(data, (key, value) => {\n          if (value && typeof value === 'object' && value.seconds !== undefined) {\n            return new Date(value.seconds * 1000).toISOString();\n          }\n          return value;\n        }));\n\n        setPermit({\n          id: docSnap.id,\n          ...sanitizedData,\n        } as Permit);\n      } else {\n        toast({\n            variant: \"destructive\",\n            title: \"Permiso no encontrado\",\n            description: \"El permiso que busca no existe o fue eliminado.\"\n        })\n        setPermit(null);\n      }\n      setLoading(false);\n    }, (error) => {\n        console.error(\"Error fetching permit:\", error);\n        // Emit a custom, catchable error for development overlay\n        const permissionError = new FirestorePermissionError({\n            path: docRef.path,\n            operation: 'get',\n        });\n        errorEmitter.emit('permission-error', permissionError);\n\n        toast({\n            variant: \"destructive\",\n            title: \"Error de Permisos\",\n            description: \"No tiene los permisos necesarios para ver este documento.\"\n        })\n        setLoading(false);\n    });\n\n    return () => unsubscribe();\n  }, [permitId, toast, user]);\n\n  if (loading) {\n    return (\n      <div className=\"flex h-full flex-1 items-center justify-center p-8\">\n        <Loader2 className=\"h-8 w-8 animate-spin text-muted-foreground\" />\n        <p className=\"ml-2 text-sm text-muted-foreground\">Cargando permiso...</p>\n      </div>\n    );\n  }\n\n  if (!permit) {\n    return (\n      <div className=\"flex h-full flex-1 items-center justify-center p-8\">\n        <p className=\"text-muted-foreground\">El permiso no pudo ser cargado o no existe.</p>\n      </div>\n    );\n  }\n\n  return <PermitDetails permit={permit} />;\n}\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAXA;;;;;;;;;;;;AAae,SAAS;IACtB,MAAM,SAAS,CAAA,GAAA,kIAAA,CAAA,YAAS,AAAD;IACvB,MAAM,EAAE,KAAK,EAAE,GAAG,CAAA,GAAA,4HAAA,CAAA,WAAQ,AAAD;IACzB,MAAM,EAAE,IAAI,EAAE,GAAG,CAAA,GAAA,4HAAA,CAAA,UAAO,AAAD;IACvB,MAAM,WAAW,MAAM,OAAO,CAAC,OAAO,EAAE,IAAI,OAAO,EAAE,CAAC,EAAE,GAAG,OAAO,EAAE;IAEpE,MAAM,CAAC,QAAQ,UAAU,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IACpD,MAAM,CAAC,SAAS,WAAW,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAEvC,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,IAAI,CAAC,UAAU;YACb,WAAW;YACX;QACF;QAEA,IAAI,CAAC,MAAM,QAAQ,6BAA6B;QAEhD,MAAM,SAAS,CAAA,GAAA,iKAAA,CAAA,MAAG,AAAD,EAAE,sHAAA,CAAA,KAAE,EAAE,WAAW;QAClC,MAAM,cAAc,CAAA,GAAA,iKAAA,CAAA,aAAU,AAAD,EAAE,QAAQ,CAAC;YACtC,IAAI,QAAQ,MAAM,IAAI;gBACpB,MAAM,OAAO,QAAQ,IAAI;gBAEzB,qEAAqE;gBACrE,MAAM,gBAAgB,KAAK,KAAK,CAAC,KAAK,SAAS,CAAC,MAAM,CAAC,KAAK;oBAC1D,IAAI,SAAS,OAAO,UAAU,YAAY,MAAM,OAAO,KAAK,WAAW;wBACrE,OAAO,IAAI,KAAK,MAAM,OAAO,GAAG,MAAM,WAAW;oBACnD;oBACA,OAAO;gBACT;gBAEA,UAAU;oBACR,IAAI,QAAQ,EAAE;oBACd,GAAG,aAAa;gBAClB;YACF,OAAO;gBACL,MAAM;oBACF,SAAS;oBACT,OAAO;oBACP,aAAa;gBACjB;gBACA,UAAU;YACZ;YACA,WAAW;QACb,GAAG,CAAC;YACA,QAAQ,KAAK,CAAC,0BAA0B;YACxC,yDAAyD;YACzD,MAAM,kBAAkB,IAAI,oHAAA,CAAA,2BAAwB,CAAC;gBACjD,MAAM,OAAO,IAAI;gBACjB,WAAW;YACf;YACA,8HAAA,CAAA,eAAY,CAAC,IAAI,CAAC,oBAAoB;YAEtC,MAAM;gBACF,SAAS;gBACT,OAAO;gBACP,aAAa;YACjB;YACA,WAAW;QACf;QAEA,OAAO,IAAM;IACf,GAAG;QAAC;QAAU;QAAO;KAAK;IAE1B,IAAI,SAAS;QACX,qBACE,8OAAC;YAAI,WAAU;;8BACb,8OAAC,iNAAA,CAAA,UAAO;oBAAC,WAAU;;;;;;8BACnB,8OAAC;oBAAE,WAAU;8BAAqC;;;;;;;;;;;;IAGxD;IAEA,IAAI,CAAC,QAAQ;QACX,qBACE,8OAAC;YAAI,WAAU;sBACb,cAAA,8OAAC;gBAAE,WAAU;0BAAwB;;;;;;;;;;;IAG3C;IAEA,qBAAO,8OAAC,+JAAA,CAAA,gBAAa;QAAC,QAAQ;;;;;;AAChC","debugId":null}}]
}