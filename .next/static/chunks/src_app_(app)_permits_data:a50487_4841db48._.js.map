{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/%28app%29/permits/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { adminDb, isAdminReady } from '@/lib/firebase-admin';\nimport { revalidatePath } from 'next/cache';\nimport type { Permit, ExternalWorker, PermitStatus, PermitClosure, Approval, UserRole, AnexoAltura, AnexoConfinado, AnexoEnergias, AnexoExcavaciones, AnexoIzaje, AnexoATS, PermitGeneralInfo, JustificacionATS, ValidacionDiaria, User, Notification } from '@/types';\nimport { FieldValue, UpdateData, Timestamp } from 'firebase-admin/firestore';\nimport { sendWhatsAppNotification } from '@/lib/notifications';\nimport { getEmailForUser, sendPermitUpdateEmail } from '@/lib/email';\nimport { config } from 'dotenv';\nconfig();\n\n// --- Funciones Auxiliares para Notificaciones ---\n\nconst getInvolvedUsers = async (permit: Permit): Promise<string[]> => {\n  const userIds = new Set<string>();\n\n  // 1. Creador del permiso\n  if (permit.createdBy) {\n    userIds.add(permit.createdBy);\n  }\n\n  // 2. Usuarios que han firmado\n  Object.values(permit.approvals || {}).forEach(approval => {\n    if (approval && approval.userId) {\n      userIds.add(approval.userId);\n    }\n  });\n\n  // 3. Roles administrativos o de supervisi√≥n que deber√≠an ser notificados\n  const adminsQuery = await adminDb.collection('users').where('role', 'in', ['admin', 'autorizante', 'lider_sst']).get();\n  adminsQuery.forEach(doc => userIds.add(doc.id));\n\n  return Array.from(userIds);\n};\n\nconst createNotification = async (\n  userId: string,\n  permit: Permit,\n  message: string,\n  type: Notification['type'],\n  triggeredBy: { uid: string, displayName: string | null }\n) => {\n  const notification: Omit<Notification, 'id'> = {\n    userId,\n    permitId: permit.id,\n    permitNumber: permit.number || '',\n    message,\n    type,\n    isRead: false,\n    createdAt: FieldValue.serverTimestamp() as Timestamp,\n    triggeredBy,\n  };\n  await adminDb.collection('notifications').add(notification as any);\n  \n  // Enviar correo electr√≥nico\n  const userEmail = await getEmailForUser(userId);\n  if (userEmail) {\n    await sendPermitUpdateEmail({\n      to: userEmail,\n      subject: `Actualizaci√≥n en Permiso SGTC: ${permit.number || permit.id}`,\n      html: `<p>${message}</p><p>Puedes ver los detalles del permiso haciendo clic <a href=\"${process.env.NEXT_PUBLIC_BASE_URL}/permits/${permit.id}\">aqu√≠</a>.</p>`\n    });\n  }\n};\n\n// --- Fin de Funciones de Notificaciones ---\n\nconst workTypesMap: {[key: string]: string} = {\n  'alturas': 'Trabajo en Alturas',\n  'confinado': 'Espacios Confinados',\n  'energia': 'Control de Energ√≠as',\n  'izaje': 'Izaje de Cargas',\n  'excavacion': 'Excavaciones',\n  'general': 'Trabajo General'\n};\n\nconst getWorkTypesString = (permit: Partial<Permit>): string => {\n  const selectedTypes: string[] = [];\n  if (permit.trabajoAlturas) selectedTypes.push('Trabajo en Alturas');\n  if (permit.espaciosConfinados) selectedTypes.push('Espacios Confinados');\n  if (permit.controlEnergia) selectedTypes.push('Control de Energ√≠as');\n  if (permit.izajeCargas) selectedTypes.push('Izaje de Cargas');\n  if (permit.excavaciones) selectedTypes.push('Excavaciones');\n  \n  if (selectedTypes.length === 0) {\n    if (permit.trabajoGeneral) return 'Trabajo General';\n    // Fallback for old data structure\n    if (permit.workType && Array.isArray(permit.workType)) {\n      return permit.workType.map(key => workTypesMap[key] || key).join(', ');\n    }\n    return 'Trabajo General';\n  }\n  return selectedTypes.join(', ');\n};\n\nconst getStatusText = (status: string) => {\n    const statusText: {[key: string]: string} = {\n      'borrador': 'Borrador',\n      'pendiente_revision': 'Pendiente de Revisi√≥n',\n      'aprobado': 'Aprobado',\n      'en_ejecucion': 'En Ejecuci√≥n',\n      'suspendido': 'Suspendido',\n      'cerrado': 'Cerrado',\n      'rechazado': 'Rechazado'\n    };\n    return statusText[status] || status;\n  };\n\nconst signatureRoles: { [key in 'solicitante' | 'autorizante' | 'mantenimiento' | 'lider_sst' | 'coordinador_alturas']: string } = {\n  coordinador_alturas: 'COORDINADOR DE TRABAJOS EN ALTURAS',\n  solicitante: 'QUIEN SOLICITA (L√çDER A CARGO DEL EQUIPO EJECUTANTE)',\n  autorizante: 'QUIEN AUTORIZA (JEFES Y DUE√ëOS DE AREA)',\n  mantenimiento: 'PERSONAL DE MANTENIMIENTO',\n  lider_sst: 'Firma SST',\n};\n\ntype PermitCreateData = Omit<Permit, 'id' | 'createdAt' | 'status' | 'createdBy' | 'number' | 'user' | 'approvals' | 'closure'> & {\n  userId: string;\n  userDisplayName: string | null;\n  userEmail: string | null;\n  userPhotoURL: string | null;\n};\n\nexport async function createPermit(data: PermitCreateData) {\n  if (!data.userId) {\n    return { success: false, error: 'User not authenticated' };\n  }\n   if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const { userId, userDisplayName, userEmail, userPhotoURL, ...permitData } = data;\n\n  const initialApprovals = {\n    solicitante: { status: 'pendiente' as const },\n    autorizante: { status: 'pendiente' as const },\n    mantenimiento: { status: 'pendiente' as const },\n    lider_sst: { status: 'pendiente' as const },\n    coordinador_alturas: { status: 'pendiente' as const },\n  };\n\n  const permitPayload: Omit<Permit, 'id'> = {\n    ...permitData,\n    status: 'pendiente_revision' as const,\n    createdBy: userId,\n    createdAt: FieldValue.serverTimestamp() as Timestamp,\n    user: {\n      displayName: userDisplayName,\n      email: userEmail,\n      photoURL: userPhotoURL,\n    },\n    approvals: initialApprovals,\n    trabajoAlturas: data.trabajoAlturas || false,\n    isSSTSignatureRequired: data.isSSTSignatureRequired || false,\n    closure: {},\n  };\n  \n  try {\n    const docRef = await adminDb.collection('permits').add(permitPayload as any);\n    const permitNumber = `PT-${Date.now()}-${docRef.id.substring(0, 6).toUpperCase()}`;\n    await docRef.update({ number: permitNumber });\n    \n    console.log('‚úÖ [Action] Permiso creado con √©xito en Firestore:', docRef.id);\n\n    const createdPermit = { ...permitPayload, id: docRef.id, number: permitNumber } as Permit;\n    const involvedUsers = await getInvolvedUsers(createdPermit);\n    const message = `Se cre√≥ un nuevo permiso de trabajo: #${permitNumber}`;\n    \n    for (const uid of involvedUsers) {\n      if (uid !== userId) {\n        await createNotification(uid, createdPermit, message, 'creation', { uid: userId, displayName: userDisplayName });\n      }\n    }\n\n    const workTypesText = getWorkTypesString(permitPayload);\n    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n    const permitUrl = `${baseUrl}/permits/${docRef.id}`;\n    \n    const messageBody = `*¬°Alerta de Seguridad SGPT!* üö®\nSe ha creado una nueva solicitud de permiso de trabajo.\n\nüìÑ *N√∫mero:* ${permitNumber}\nüë§ *Solicitante:* ${userDisplayName || 'N/A'}\nüõ†Ô∏è *Tipo de Trabajo:* ${workTypesText}\n\nPor favor, revise la solicitud para su aprobaci√≥n en el siguiente enlace:\n${permitUrl}`;\n    \n    await sendWhatsAppNotification(messageBody);\n    \n    revalidatePath('/permits');\n    revalidatePath('/dashboard');\n    \n    return { success: true, permitId: docRef.id, permitNumber };\n  } catch (error: any) {\n    console.error(\"‚ùå [Action] Error al crear permiso:\", error);\n    return { \n      success: false, \n      error: error.message || 'Could not create permit. Please try again.' \n    };\n  }\n}\n\nexport async function savePermitDraft(data: PermitCreateData & { draftId?: string }) {\n  if (!data.userId) {\n    return { success: false, error: 'User not authenticated' };\n  }\n  if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const { userId, userDisplayName, userEmail, userPhotoURL, draftId, ...permitData } = data;\n\n  const initialApprovals = {\n    solicitante: { status: 'pendiente' as const },\n    autorizante: { status: 'pendiente' as const },\n    mantenimiento: { status: 'pendiente' as const },\n    lider_sst: { status: 'pendiente' as const },\n    coordinador_alturas: { status: 'pendiente' as const },\n  };\n\n  const permitPayload: Omit<Permit, 'id' | 'createdAt'> = {\n    ...permitData,\n    status: 'borrador' as const,\n    createdBy: userId,\n    user: {\n      displayName: userDisplayName,\n      email: userEmail,\n      photoURL: userPhotoURL,\n    },\n    approvals: initialApprovals,\n    trabajoAlturas: data.trabajoAlturas || false,\n    isSSTSignatureRequired: data.isSSTSignatureRequired || false,\n  };\n\n  try {\n    if (draftId) {\n      // Actualizar un borrador existente\n      const docRef = adminDb.collection('permits').doc(draftId);\n      await docRef.update({ ...permitPayload, updatedAt: FieldValue.serverTimestamp() });\n      revalidatePath(`/permits/${draftId}`);\n      revalidatePath('/permits');\n      return { success: true, permitId: draftId, isUpdate: true };\n    } else {\n      // Crear un nuevo borrador\n      const payloadWithTimestamp = { ...permitPayload, createdAt: FieldValue.serverTimestamp() };\n      const docRef = await adminDb.collection('permits').add(payloadWithTimestamp as any);\n      revalidatePath('/permits');\n      return { success: true, permitId: docRef.id, isUpdate: false };\n    }\n  } catch (error: any) {\n    console.error(\"‚ùå [Action] Error al guardar borrador:\", error);\n    return { \n      success: false, \n      error: error.message || 'Could not save draft. Please try again.' \n    };\n  }\n}\n\nexport async function addSignatureAndNotify(\n  permitId: string, \n  role: 'solicitante' | 'autorizante' | 'mantenimiento' | 'lider_sst' | 'coordinador_alturas' | 'cierre_autoridad' | 'cierre_responsable' | 'cancelacion', \n  signatureType: 'firmaApertura' | 'firmaCierre',\n  signatureDataUrl: string,\n  user: { uid: string, displayName: string | null, role?: UserRole, empresa?: string },\n  comments?: string\n) {\n    if (!permitId || !role || !user || !user.uid || !user.role) {\n        return { success: false, error: 'Par√°metros inv√°lidos para guardar la firma.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n    }\n\n    try {\n        const docRef = adminDb.collection('permits').doc(permitId);\n        const permitDocBefore = await docRef.get();\n        if (!permitDocBefore.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n        const permitBeforeData = permitDocBefore.data() as Permit;\n\n        const updateData: UpdateData<Permit> = {};\n\n        // L√≥gica para manejar firmas de cierre y cancelaci√≥n\n        if (role.startsWith('cierre_') || role === 'cancelacion') {\n            const closureRole = role === 'cierre_autoridad' ? 'autoridad' : (role === 'cierre_responsable' ? 'responsable' : 'canceladoPor');\n            const closurePath = `closure.${closureRole}`;\n            \n            const existingClosureData = (permitBeforeData.closure as any)?.[closureRole] || {};\n\n            updateData[closurePath as keyof UpdateData<Permit>] = {\n                ...existingClosureData,\n                firma: signatureDataUrl,\n                nombre: user.displayName,\n                fecha: FieldValue.serverTimestamp() \n            };\n            \n            if (role === 'cancelacion') {\n                updateData['closure.razonCancelacion'] = comments || 'No especificado';\n                updateData['closure.cancelado'] = 'si';\n            }\n\n        } else {\n            // ‚úÖ VALIDACI√ìN DE PERMISOS ANTES DE FIRMAR\n            const canSign = await validateSignaturePermission(permitId, role, user);\n            if (!canSign.allowed) {\n                return { success: false, error: canSign.reason };\n            }\n\n            const approvalData: Partial<Approval> = {\n                status: 'aprobado',\n                firmaApertura: signatureDataUrl,\n                userName: user.displayName,\n                userId: user.uid,\n                signedAt: FieldValue.serverTimestamp() as any,\n                userRole: user.role,\n                userEmpresa: user.empresa || 'N/A',\n                comments: comments || '',\n            }\n            \n            updateData[`approvals.${role}`] = approvalData;\n            \n            // ‚úÖ L√ìGICA DE FIRMAS SEG√öN EL ROL\n            if (signatureType === 'firmaApertura') {\n                const validationPayload: ValidacionDiaria = { \n                    dia: 1, \n                    nombre: user.displayName || '', \n                    firma: signatureDataUrl, \n                    fecha: new Date().toISOString() \n                };\n                \n                // ‚úÖ SOLICITANTE FIRMA: Cambia de Borrador a Pendiente de Revisi√≥n\n                if (role === 'solicitante') {\n                    if (permitBeforeData.status === 'borrador') {\n                        const permitNumber = `PT-${Date.now()}-${permitId.substring(0, 6).toUpperCase()}`;\n                        updateData['number'] = permitNumber;\n                        updateData['status'] = 'pendiente_revision';\n                    }\n                    \n                    // Validaci√≥n diaria inicial del responsable\n                    ['anexoAltura', 'anexoConfinado', 'anexoIzaje', 'anexoExcavaciones'].forEach(anexo => {\n                        if ((permitBeforeData as any)?.[anexo]) {\n                            const currentValidations = (permitBeforeData as any)[anexo].validacion?.responsable || [];\n                            if (!currentValidations[0]?.firma) {\n                                currentValidations[0] = validationPayload;\n                                updateData[`${anexo}.validacion.responsable`] = currentValidations;\n                            }\n                        }\n                    });\n\n                // ‚úÖ AUTORIZANTE FIRMA: Agrega validaci√≥n diaria de autoridad\n                } else if (role === 'autorizante') {\n                    ['anexoAltura', 'anexoConfinado', 'anexoIzaje', 'anexoExcavaciones'].forEach(anexo => {\n                        if ((permitBeforeData as any)?.[anexo]) {\n                           const currentValidations = (permitBeforeData as any)[anexo].validacion?.autoridad || [];\n                            if (!currentValidations[0]?.firma) {\n                                currentValidations[0] = validationPayload;\n                                updateData[`${anexo}.validacion.autoridad`] = currentValidations;\n                            }\n                        }\n                    });\n                }\n            }\n\n            // ‚úÖ VERIFICACI√ìN AUTOM√ÅTICA: ¬øTodas las firmas requeridas est√°n completas?\n            const updatedPermitData = { \n                ...permitBeforeData, \n                approvals: { ...permitBeforeData.approvals, [role]: approvalData }\n            };\n            \n            if (await checkAllRequiredSignaturesComplete(updatedPermitData)) {\n                // üöÄ CAMBIO AUTOM√ÅTICO DE PENDIENTE_REVISION ‚Üí EN_EJECUCION\n                if (permitBeforeData.status === 'pendiente_revision') {\n                    updateData['status'] = 'en_ejecucion';\n                }\n            }\n        }\n        \n        await docRef.update(updateData);\n        \n        const permitDoc = await docRef.get();\n        const updatedPermitData = { id: permitDoc.id, ...permitDoc.data() } as Permit;\n        \n        const signatureRoleName = (signatureRoles as any)[role] || role.replace('_', ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n        \n        const message = `${user.displayName || 'Un usuario'} ha firmado el permiso #${updatedPermitData.number} como ${signatureRoleName}.`;\n        const involvedUsers = await getInvolvedUsers(updatedPermitData);\n        \n        for (const uid of involvedUsers) {\n          if (uid !== user.uid) {\n            await createNotification(uid, updatedPermitData, message, 'signature', user);\n          }\n        }\n        \n        // ‚úÖ NOTIFICACI√ìN ESPECIAL SI EL PERMISO PAS√ì AUTOM√ÅTICAMENTE A EN_EJECUCION\n        if (updateData['status'] === 'en_ejecucion') {\n            const executionMessage = `El permiso #${updatedPermitData.number} ha completado todas las aprobaciones requeridas y ahora est√° EN EJECUCI√ìN.`;\n            for (const uid of involvedUsers) {\n                 await createNotification(uid, updatedPermitData, executionMessage, 'approval', user);\n            }\n            \n            // Notificaci√≥n WhatsApp\n            const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n            const permitUrl = `${baseUrl}/permits/${permitId}`;\n            const whatsappMsg = `*¬°PERMISO EN EJECUCI√ìN!* ‚úÖ\n\nüìÑ *N√∫mero:* ${updatedPermitData.number}\nüìç *√Årea:* ${permitBeforeData.generalInfo?.areaEspecifica || 'N/A'}\nüõ†Ô∏è *Tipo:* ${getWorkTypesString(permitBeforeData)}\n\n‚úÖ Todas las firmas requeridas han sido completadas.\nEl permiso est√° ahora EN EJECUCI√ìN.\n\nVer detalles: ${permitUrl}`;\n            \n            await sendWhatsAppNotification(whatsappMsg);\n        }\n\n        revalidatePath(`/permits/${permitId}`);\n        return { success: true };\n\n    } catch (error: any) {\n        console.error(\"‚ùå Error al guardar firma y notificar:\", error);\n        return {\n            success: false,\n            error: error.message || 'No se pudo guardar la firma.'\n        };\n    }\n}\n\n// ‚úÖ FUNCI√ìN CORREGIDA: Verificar si todas las firmas requeridas est√°n completas\nasync function checkAllRequiredSignaturesComplete(\n  permitData: Permit\n): Promise<boolean> {\n    const { approvals } = permitData;\n    \n    // Firma del solicitante es SIEMPRE requerida\n    if (approvals?.solicitante?.status !== 'aprobado') {\n        return false;\n    }\n    \n    // Firma del autorizante es SIEMPRE requerida\n    if (approvals?.autorizante?.status !== 'aprobado') {\n        return false;\n    }\n    \n    // Si hay trabajos en alturas, requiere firma del coordinador\n    if (permitData.trabajoAlturas || permitData.selectedWorkTypes?.alturas) {\n        if (approvals?.coordinador_alturas?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    // Si hay control de energ√≠a, requiere firma de mantenimiento\n    if (permitData.controlEnergia) {\n        if (approvals?.mantenimiento?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    // Si SST es requerido, validar su firma\n    if (permitData.isSSTSignatureRequired) {\n        if (approvals?.lider_sst?.status !== 'aprobado') {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n// ‚úÖ FUNCI√ìN MEJORADA: Validaci√≥n de transiciones de estado\nfunction validateStateTransition(currentStatus: PermitStatus, targetStatus: PermitStatus, userRole: UserRole): { allowed: boolean, reason?: string } {\n    const allowedTransitions: Partial<Record<PermitStatus, Partial<Record<PermitStatus, UserRole[]>>>> = {\n        'borrador': {\n            'pendiente_revision': ['solicitante', 'lider_tarea', 'admin']\n        },\n        'pendiente_revision': {\n            'en_ejecucion': ['autorizante', 'admin'],\n            'rechazado': ['autorizante', 'lider_sst', 'admin']\n        },\n        'en_ejecucion': {\n            'suspendido': ['lider_sst', 'admin'],\n            'cerrado': ['lider_tarea', 'autorizante', 'admin']\n        },\n        'suspendido': {\n            'en_ejecucion': ['lider_sst', 'admin'],\n            'cerrado': ['lider_tarea', 'autorizante', 'admin']\n        },\n        // Mantener compatibilidad con permisos antiguos que tengan estado \"aprobado\"\n        'aprobado': {\n            'en_ejecucion': ['lider_tarea', 'admin'],\n            'rechazado': ['autorizante', 'lider_sst', 'admin']\n        }\n    };\n    \n    const allowedRoles = allowedTransitions[currentStatus]?.[targetStatus];\n    if (!allowedRoles) {\n        return { allowed: false, reason: `Transici√≥n de '${currentStatus}' a '${targetStatus}' no est√° permitida.` };\n    }\n\n    if (!allowedRoles.includes(userRole) && userRole !== 'admin') {\n        return { allowed: false, reason: `Tu rol (${userRole}) no tiene permisos para cambiar el estado a '${targetStatus}'.` };\n    }\n\n    return { allowed: true };\n}\n\nexport async function updatePermitStatus(\n  permitId: string,\n  status: PermitStatus,\n  currentUser: { uid: string, displayName: string | null, role?: UserRole },\n  reason?: string\n) {\n    if (!permitId || !currentUser.uid || !currentUser.role) {\n        return { success: false, error: 'Par√°metros inv√°lidos o usuario sin rol.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas.' };\n    }\n\n    try {\n        const docRef = adminDb.collection('permits').doc(permitId);\n        const permitSnap = await docRef.get();\n        if (!permitSnap.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n        const permitData = permitSnap.data() as Permit;\n        \n        // ‚úÖ Validar transici√≥n de estado\n        const transition = validateStateTransition(permitData.status, status, currentUser.role);\n        if (!transition.allowed) {\n            return { success: false, error: transition.reason };\n        }\n\n        const updateData: UpdateData<Permit> = { status };\n\n        // ‚úÖ Guardar raz√≥n de rechazo\n        if (status === 'rechazado' && reason) {\n            updateData.rejectionReason = reason;\n        }\n        \n        // ‚úÖ Marcar fecha de cierre\n        if (status === 'cerrado') {\n            updateData['closure.fechaCierre'] = FieldValue.serverTimestamp();\n            updateData['closure.terminado'] = 'si';\n        }\n\n        await docRef.update(updateData);\n        \n        const updatedPermitData = { ...permitData, ...updateData, id: permitId } as Permit;\n        const triggeredBy = currentUser;\n        \n        let notificationType: Notification['type'] = 'status_change';\n        let message = `${currentUser.displayName || 'Un usuario'} ha cambiado el estado del permiso #${permitData.number} a: ${getStatusText(status)}.`;\n\n        if (status === 'en_ejecucion') {\n            notificationType = 'approval';\n            message = `El permiso #${permitData.number} ha sido puesto EN EJECUCI√ìN manualmente.`;\n        } else if (status === 'rechazado') {\n            notificationType = 'rejection';\n            message = `${currentUser.displayName || 'Un usuario'} ha rechazado el permiso #${permitData.number}.`;\n            if (reason) message += ` Motivo: ${reason}`;\n        } else if (status === 'cerrado') {\n            notificationType = 'cancellation';\n            message = `${currentUser.displayName || 'Un usuario'} ha cerrado el permiso #${permitData.number}.`;\n        }\n        \n        const involvedUsers = await getInvolvedUsers(updatedPermitData);\n        for (const uid of involvedUsers) {\n             if (uid !== currentUser.uid) {\n                await createNotification(uid, updatedPermitData, message, notificationType, triggeredBy);\n            }\n        }\n\n        const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n        const permitUrl = `${baseUrl}/permits/${permitId}`;\n\n        let messageBody = `*Actualizaci√≥n de Estado - SGTC* üîÑ\nEl estado del permiso *${permitData.number || permitId}* ha cambiado.\n\n*Nuevo Estado:* ${getStatusText(status)}\n\nPuede ver los detalles aqu√≠:\n${permitUrl}`;\n\n        if (status === 'rechazado' && reason) {\n          messageBody += `\\n\\n*Motivo del rechazo:* ${reason}`;\n        }\n        \n        await sendWhatsAppNotification(messageBody);\n        \n        revalidatePath(`/permits/${permitId}`);\n        revalidatePath('/permits');\n        revalidatePath('/dashboard');\n\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"‚ùå Error updating permit status:\", error);\n        return {\n            success: false,\n            error: error.message || 'Could not update permit status.'\n        };\n    }\n}\n\n// ‚úÖ FUNCI√ìN MEJORADA: Validaci√≥n de permisos de firma con orden jer√°rquico\nasync function validateSignaturePermission(\n    permitId: string, \n    signatureRole: string, \n    currentUser: { uid: string, role?: UserRole }\n): Promise<{ allowed: boolean, reason?: string }> {\n    const docRef = adminDb.collection('permits').doc(permitId);\n    const permitDoc = await docRef.get();\n    if (!permitDoc.exists) {\n        return { allowed: false, reason: 'Permiso no encontrado.' };\n    }\n    const permit = permitDoc.data() as Permit;\n    \n    // ‚úÖ Verificar que el permiso est√© en un estado v√°lido para firmar\n    if (!['borrador', 'pendiente_revision'].includes(permit.status)) {\n        return { allowed: false, reason: `No se puede firmar un permiso en estado '${permit.status}'.` };\n    }\n    \n    switch (signatureRole) {\n        case 'coordinador_alturas':\n            // Debe haber trabajo en alturas\n            if (!permit.trabajoAlturas && !permit.selectedWorkTypes?.alturas) {\n                return { allowed: false, reason: 'Esta firma solo aplica para trabajos en alturas.' };\n            }\n            // Solo el creador o admin puede gestionar esta firma\n            if (permit.createdBy !== currentUser.uid && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Solo el creador del permiso puede gestionar esta firma.' };\n            }\n            break;\n            \n        case 'solicitante':\n            if (permit.createdBy !== currentUser.uid && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Solo el creador del permiso puede firmar como solicitante.' };\n            }\n            // ‚úÖ Si hay anexo de alturas, verificar firma del coordinador primero\n            if ((permit.trabajoAlturas || permit.selectedWorkTypes?.alturas) && \n                permit.approvals?.coordinador_alturas?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del Coordinador de Trabajos en Alturas.' };\n            }\n            break;\n            \n        case 'autorizante':\n            if (currentUser.role !== 'autorizante' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de autorizante requerido para esta firma.' };\n            }\n            if (permit.approvals?.solicitante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del solicitante.' };\n            }\n            break;\n            \n        case 'lider_sst':\n            if (currentUser.role !== 'lider_sst' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de L√≠der SST requerido para esta firma.' };\n            }\n            // ‚úÖ Solo requerido si isSSTSignatureRequired es true\n            if (!permit.isSSTSignatureRequired) {\n                return { allowed: false, reason: 'Firma de SST no es requerida para este permiso.' };\n            }\n            if (permit.approvals?.solicitante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del solicitante.' };\n            }\n            break;\n            \n        case 'mantenimiento':\n             if (currentUser.role !== 'mantenimiento' && currentUser.role !== 'admin') {\n                return { allowed: false, reason: 'Rol de Mantenimiento requerido para esta firma.' };\n            }\n            if (!permit.controlEnergia) {\n                return { allowed: false, reason: 'Firma de Mantenimiento solo aplica cuando hay control de energ√≠as.' };\n            }\n            if (permit.approvals?.autorizante?.status !== 'aprobado') {\n                return { allowed: false, reason: 'Se requiere primero la firma del autorizante.' };\n            }\n            break;\n    }\n    \n    return { allowed: true };\n}\n\nexport async function addDailyValidationSignature(\n  permitId: string, \n  anexoName: string, \n  validationType: 'autoridad' | 'responsable', \n  index: number, \n  data: ValidacionDiaria, \n  user: User\n) {\n  if (!permitId || !anexoName || !validationType || index < 0 || !data || !user) {\n    return { success: false, error: 'Par√°metros inv√°lidos.' };\n  }\n\n  if (!isAdminReady()) {\n    return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n  }\n\n  const docRef = adminDb.collection('permits').doc(permitId);\n  try {\n    const permitSnap = await docRef.get();\n    if (!permitSnap.exists) {\n      return { success: false, error: 'El permiso no existe.' };\n    }\n    const permitData = permitSnap.data() as Permit;\n\n    // ‚úÖ Verificar que el permiso est√© en ejecuci√≥n para validaciones diarias\n    if (!['en_ejecucion', 'suspendido'].includes(permitData.status)) {\n        return { success: false, error: 'Solo se pueden agregar validaciones diarias en permisos EN EJECUCI√ìN o SUSPENDIDOS.' };\n    }\n\n    const anexoData = (permitData as any)[anexoName];\n    if (!anexoData) {\n      return { success: false, error: `El anexo ${anexoName} no existe en el permiso.` };\n    }\n    \n    const anexoUpdate: any = { ...anexoData };\n    if (!anexoUpdate.validacion) {\n        anexoUpdate.validacion = { autoridad: [], responsable: [] };\n    }\n\n    const validationArray = (anexoUpdate.validacion[validationType] as ValidacionDiaria[]) || [];\n    \n    while (validationArray.length <= index) {\n        validationArray.push({ dia: validationArray.length + 1, nombre: '', fecha: '', firma: '' });\n    }\n\n    validationArray[index] = data;\n    \n    const updatePath = `${anexoName}.validacion.${validationType}`;\n    \n    await docRef.update({\n      [updatePath]: validationArray,\n    });\n\n    const fullPermitData = { id: docRef.id, ...permitData } as Permit;\n    const anexoDisplayName = anexoName.replace('anexo', 'Anexo ');\n    const validationRoleName = validationType === 'autoridad' ? 'Autoridad del √Årea' : 'Responsable del Trabajo';\n    const day = index + 1;\n\n    const message = `${user.displayName || 'Un usuario'} ha realizado la validaci√≥n diaria (${validationRoleName}) para el D√çA ${day} del ${anexoDisplayName} en el permiso #${fullPermitData.number}.`;\n    const involvedUsers = await getInvolvedUsers(fullPermitData);\n    for (const uid of involvedUsers) {\n      if (uid !== user.uid) {\n        await createNotification(uid, fullPermitData, message, 'status_change', { uid: user.uid, displayName: user.displayName || null });\n      }\n    }\n\n    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://sgpt-movil.web.app';\n    const permitUrl = `${baseUrl}/permits/${permitId}`;\n    const whatsappMessage = `*Validaci√≥n Diaria - SGTC* ‚úçÔ∏è\nSe ha registrado una nueva firma de validaci√≥n diaria.\n\nüìÑ *Permiso:* ${fullPermitData.number || 'N/A'}\nüóìÔ∏è *D√≠a:* ${day}\nüë§ *Firmante:* ${user.displayName || 'N/A'}\n‚úÖ *Rol:* ${validationRoleName}\nüìã *Anexo:* ${anexoDisplayName}\n\nPuede ver los detalles aqu√≠:\n${permitUrl}`;\n    \n    await sendWhatsAppNotification(whatsappMessage);\n\n    revalidatePath(`/permits/${permitId}`);\n    return { success: true };\n\n  } catch (error: any) {\n    console.error(\"‚ùå Error al guardar la validaci√≥n diaria:\", error);\n    return { success: false, error: 'No se pudo guardar la firma de validaci√≥n.' };\n  }\n}\n\nexport async function addWorkerSignature(permitId: string, workerIndex: number, signatureType: 'firmaApertura' | 'firmaCierre', signatureDataUrl: string) {\n    if (!permitId || workerIndex < 0 || !signatureType || !signatureDataUrl) {\n        return { success: false, error: 'Faltan par√°metros.' };\n    }\n    if (!isAdminReady()) {\n      return { success: false, error: 'Credenciales de administrador de Firebase no configuradas en el servidor.' };\n    }\n\n    const docRef = adminDb.collection('permits').doc(permitId);\n    try {\n        const permitSnap = await docRef.get();\n        if (!permitSnap.exists) {\n            return { success: false, error: 'El permiso no existe.' };\n        }\n\n        const permitData = permitSnap.data() as Permit;\n        \n        // ‚úÖ CORRECCI√ìN: Validaci√≥n de estado corregida para firma de apertura\n        if (signatureType === 'firmaApertura' && !['pendiente_revision', 'aprobado', 'en_ejecucion'].includes(permitData.status)) {\n            return { success: false, error: 'Solo se puede firmar apertura cuando el permiso est√° pendiente, aprobado o en ejecuci√≥n.' };\n        }\n        if (signatureType === 'firmaCierre' && !['en_ejecucion', 'suspendido'].includes(permitData.status)) {\n            return { success: false, error: 'Solo se puede firmar cierre en permisos EN EJECUCI√ìN o SUSPENDIDOS.' };\n        }\n        \n        const workers = permitData.workers ? [...permitData.workers] : [];\n\n        if (workerIndex >= workers.length) {\n            return { success: false, error: '√çndice de trabajador inv√°lido.' };\n        }\n\n        const signatureField = signatureType === 'firmaApertura' ? 'firmaApertura' : 'firmaCierre';\n        const dateField = signatureType === 'firmaApertura' ? 'fechaFirmaApertura' : 'fechaFirmaCierre';\n\n        workers[workerIndex] = {\n            ...workers[workerIndex],\n            [signatureField]: signatureDataUrl,\n            [dateField]: new Date().toISOString(), \n        };\n\n        await docRef.update({ workers: workers });\n\n        revalidatePath(`/permits/${permitId}`);\n        return { success: true };\n    } catch (error: any) {\n        console.error(\"Error al guardar la firma del trabajador:\", error);\n        return { success: false, error: 'No se pudo guardar la firma.' };\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA4MsB,kBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}}]
}